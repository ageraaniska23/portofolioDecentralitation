import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { CheckCircledIcon, CrossCircledIcon } from "@radix-ui/react-icons";
import { useState } from "react";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../../../constants/addresses.js";
import { getContract } from "../../../../../../../contract/contract.js";
import { transfer } from "../../../../../../../extensions/erc20/write/transfer.js";
import { sendAndConfirmTransaction } from "../../../../../../../transaction/actions/send-and-confirm-transaction.js";
import { prepareTransaction } from "../../../../../../../transaction/prepare-transaction.js";
import { toWei } from "../../../../../../../utils/units.js";
import { iconSize } from "../../../../../../core/design-system/index.js";
import { useChainSymbol } from "../../../../../../core/hooks/others/useChainQuery.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { StepBar } from "../../../../components/StepBar.js";
import { SwitchNetworkButton } from "../../../../components/SwitchNetwork.js";
import { Container, Line, ModalHeader } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { isNativeToken } from "../../nativeToken.js";
import { Step } from "../Stepper.js";
import { WalletRow } from "../WalletSelectorButton.js";
import { TokenInfoRow } from "../pay-transactions/TokenInfoRow.js";
import { ConnectorLine } from "./ConfirmationScreen.js";
export function TransferFlow(props) {
    const { title, onBack, receiverAddress, client, payer, onDone, chain, token, tokenAmount, transactionMode, } = props;
    const [step, setStep] = useState("transfer");
    const [status, setStatus] = useState("idle");
    const { symbol } = useChainSymbol(chain);
    return (_jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { title: title, onBack: onBack }), _jsx(Spacer, { y: "xl" }), transactionMode && (_jsxs(_Fragment, { children: [_jsx(StepBar, { steps: 2, currentStep: step === "transfer" ? 1 : 2 }), _jsx(Spacer, { y: "sm" }), _jsx(Text, { size: "sm", children: step === "transfer"
                            ? "Step 1 of 2 - Transfer funds"
                            : "Step 2 of 2 - Finalize transaction" }), _jsx(Spacer, { y: "xl" })] })), _jsxs(Container, { flex: "row", center: "y", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "sm", children: "From" }), _jsx(WalletRow, { address: payer.account.address, client: client })] }), _jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "md" }), _jsxs(Container, { flex: "row", center: "y", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "sm", children: "To" }), _jsx(WalletRow, { address: receiverAddress, client: client })] }), _jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "md" }), _jsx(TokenInfoRow, { chainId: chain.id, client: client, label: "Amount", tokenAmount: tokenAmount, tokenSymbol: isNativeToken(token) ? symbol || "" : token.symbol, tokenAddress: isNativeToken(token) ? NATIVE_TOKEN_ADDRESS : token.address }), _jsx(Spacer, { y: "lg" }), transactionMode && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "sm" }), _jsxs(Container, { gap: "sm", flex: "row", style: {
                            justifyContent: "space-between",
                        }, center: "y", color: "accentText", children: [_jsx(Step, { isDone: step === "execute", isActive: step === "transfer", label: step === "transfer" ? "Transfer" : "Done" }), _jsx(ConnectorLine, {}), _jsx(Step, { isDone: false, label: "Finalize", isActive: step === "execute" })] }), _jsx(Spacer, { y: "lg" })] })), status === "error" && (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "xs", center: "both", color: "danger", children: [_jsx(CrossCircledIcon, { width: iconSize.sm, height: iconSize.sm }), _jsx(Text, { color: "danger", size: "sm", children: step === "transfer" ? "Failed to Transfer" : "Failed to Execute" })] }), _jsx(Spacer, { y: "md" })] })), !transactionMode && step === "execute" && status === "done" && (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "xs", center: "both", color: "success", children: [_jsx(CheckCircledIcon, { width: iconSize.sm, height: iconSize.sm }), _jsx(Text, { color: "success", size: "sm", children: "Payment completed" })] }), _jsx(Spacer, { y: "md" })] })), payer.chain.id !== chain.id ? (_jsx(SwitchNetworkButton, { fullWidth: true, variant: "accent", switchChain: async () => {
                    await props.payer.wallet.switchChain(chain);
                } })) : (_jsxs(Button, { variant: "accent", fullWidth: true, disabled: status === "pending", onClick: async () => {
                    if (step === "execute") {
                        onDone();
                        return;
                    }
                    try {
                        setStatus("pending");
                        const transaction = isNativeToken(token)
                            ? prepareTransaction({
                                client,
                                chain,
                                to: receiverAddress,
                                value: toWei(tokenAmount),
                            })
                            : transfer({
                                contract: getContract({
                                    address: token.address,
                                    chain: chain,
                                    client: client,
                                }),
                                to: receiverAddress,
                                amount: tokenAmount,
                            });
                        await sendAndConfirmTransaction({
                            account: props.payer.account,
                            transaction,
                        });
                        setStep("execute");
                        if (transactionMode) {
                            setStatus("idle");
                        }
                        else {
                            setStatus("done");
                        }
                    }
                    catch (e) {
                        console.error(e);
                        setStatus("error");
                    }
                }, gap: "xs", children: [step === "execute" && (status === "done" ? "Done" : "Continue"), step === "transfer" &&
                        (status === "pending" ? "Confirming" : "Confirm"), status === "pending" && (_jsx(Spinner, { size: "sm", color: "accentButtonText" }))] }))] }));
}
//# sourceMappingURL=TransferFlow.js.map