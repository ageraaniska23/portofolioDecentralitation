"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInAppWallet = isInAppWallet;
exports.connectInAppWallet = connectInAppWallet;
exports.autoConnectInAppWallet = autoConnectInAppWallet;
const ethereum_js_1 = require("../../../../chains/chain-definitions/ethereum.js");
const types_js_1 = require("../../../../wallets/types.js");
const type_js_1 = require("../authentication/type.js");
/**
 * Checks if the provided wallet is an in-app wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is an in-app wallet, false otherwise.
 */
function isInAppWallet(wallet) {
    return wallet.id === "inApp" || wallet.id === "embedded";
}
/**
 * @internal
 */
async function connectInAppWallet(options, createOptions, connector) {
    if (createOptions?.auth?.mode === "redirect" &&
        connector.authenticateWithRedirect) {
        const strategy = options.strategy;
        if (types_js_1.socialAuthOptions.includes(strategy)) {
            connector.authenticateWithRedirect(strategy);
        }
    }
    // If we don't have authenticateWithRedirect then it's likely react native, so the default is to redirect and we can carry on
    // IF WE EVER ADD MORE CONNECTOR TYPES, this could cause redirect to be ignored despite being specified
    // TODO: In V6, make everything redirect auth
    const authResult = await connector.authenticate(options);
    const authAccount = authResult.user.account;
    if (createOptions &&
        "smartAccount" in createOptions &&
        createOptions?.smartAccount) {
        return convertToSmartAccount({
            client: options.client,
            authAccount,
            smartAccountOptions: createOptions.smartAccount,
            chain: options.chain,
        });
    }
    return [authAccount, options.chain || ethereum_js_1.ethereum];
}
/**
 * @internal
 */
async function autoConnectInAppWallet(options, createOptions, connector) {
    if (options.authResult && connector.loginWithAuthToken) {
        await connector.loginWithAuthToken(options.authResult);
    }
    const user = await getAuthenticatedUser(connector);
    if (!user) {
        throw new Error("Failed to authenticate user.");
    }
    const authAccount = user.account;
    if (createOptions &&
        "smartAccount" in createOptions &&
        createOptions?.smartAccount) {
        return convertToSmartAccount({
            client: options.client,
            authAccount,
            smartAccountOptions: createOptions.smartAccount,
            chain: options.chain,
        });
    }
    return [authAccount, options.chain || ethereum_js_1.ethereum];
}
async function convertToSmartAccount(options) {
    const [{ smartWallet }, { connectSmartWallet }] = await Promise.all([
        Promise.resolve().then(() => require("../../../smart/smart-wallet.js")),
        Promise.resolve().then(() => require("../../../smart/index.js")),
    ]);
    const sa = smartWallet(options.smartAccountOptions);
    return connectSmartWallet(sa, {
        client: options.client,
        personalAccount: options.authAccount,
        chain: options.chain,
    }, options.smartAccountOptions);
}
async function getAuthenticatedUser(connector) {
    const user = await connector.getUser();
    switch (user.status) {
        case type_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
            return user;
        }
    }
    return undefined;
}
//# sourceMappingURL=index.js.map