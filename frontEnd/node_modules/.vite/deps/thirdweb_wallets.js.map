{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/signatures/signature-to-hex.ts", "../../thirdweb/src/utils/signatures/sign-message.ts", "../../thirdweb/src/utils/signatures/sign-typed-data.ts", "../../thirdweb/src/wallets/private-key.ts", "../../thirdweb/src/wallets/utils/generateAccount.ts", "../../thirdweb/src/wallets/getAllWalletsList.ts", "../../thirdweb/src/adapters/wallet-adapter.ts"],
  "sourcesContent": ["import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type { Signature } from \"viem\";\nimport { type Hex, hexToBigInt } from \"../encoding/hex.js\";\n\n/**\n * Converts a signature to a hex string.\n * @param signature The signature to convert.\n * @returns The hex string representation of the signature.\n * @example\n * ```ts\n * import { signatureToHex } from \"thirdweb/utils\";\n *\n * const hex = signatureToHex({\n * r: toHex(\n * 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * ),\n * s: toHex(\n * 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * ),\n * v: 28n,\n * });\n *\n * console.log(hex);\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n * ```\n * @utils\n */\nexport function signatureToHex(signature: Signature): Hex {\n  const { r, s, v, yParity } = signature;\n  const yParity_ = (() => {\n    if (yParity === 0 || yParity === 1) return yParity;\n    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0;\n    throw new Error(\"Invalid `v` or `yParity` value\");\n  })();\n  return `0x${new secp256k1.Signature(\n    hexToBigInt(r),\n    hexToBigInt(s),\n  ).toCompactHex()}${yParity_ === 0 ? \"1b\" : \"1c\"}`;\n}\n", "import type { Hex } from \"../encoding/hex.js\";\nimport { hashMessage } from \"../hashing/hashMessage.js\";\nimport type { Prettify } from \"../type-utils.js\";\nimport { sign } from \"./sign.js\";\nimport { signatureToHex } from \"./signature-to-hex.js\";\n\nexport type SignMessageOptions = {\n  message: Prettify<\n    | string\n    | {\n        raw: Hex | Uint8Array;\n      }\n  >;\n  privateKey: Hex;\n};\n\n/**\n * Signs a string message with a given private key.\n * @param options The options for signing.\n * @param options.message The message to be signed as a string or object containing raw hex or bytes\n * @param options.privateKey The private key to be used\n * @returns The signature as a hex string\n * @example\n * ```ts\n * import { signMessage } from \"thirdweb/utils\";\n * signMessage({\n *   message: \"Hello, world!\",\n *   privateKey: \"0x...\",\n * });\n * ```\n * @utils\n */\nexport function signMessage({ message, privateKey }: SignMessageOptions): Hex {\n  const signature = sign({ hash: hashMessage(message), privateKey });\n  return signatureToHex(signature);\n}\n", "import type { TypedData } from \"abitype\";\nimport { type TypedDataDefinition, hashTypedData } from \"viem\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { parseTypedData } from \"./helpers/parseTypedData.js\";\nimport { sign } from \"./sign.js\";\nimport { signatureToHex } from \"./signature-to-hex.js\";\n\nexport type SignTypedDataOptions<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  privateKey: Hex;\n};\n\n/**\n * Signs a typed data object with a given private key according to EIP712.\n * @param options The typed data is passed within options alongside the private key\n * @param options.privateKey The private key to sign the typed data with\n * @returns The signature as a hex string\n * @example\n * ```ts\n * import { signTypedData } from \"thirdweb/utils\";\n * signTypedData({\n *   privateKey: \"0x...\",\n *   ...typedData\n * });\n * ```\n * @utils\n */\nexport function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>(options: SignTypedDataOptions<typedData, primaryType>): Hex {\n  const { privateKey, ...typedData } =\n    options as unknown as SignTypedDataOptions;\n\n  const parsedTypeData = parseTypedData(typedData);\n\n  const signature = sign({\n    hash: hashTypedData(parsedTypeData), // TODO: Implement native hashTypedData\n    privateKey,\n  });\n  return signatureToHex(signature);\n}\n", "import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type {\n  SignableMessage,\n  TransactionSerializable,\n  TypedData,\n  TypedDataDefinition,\n} from \"viem\";\nimport { publicKeyToAddress } from \"viem/utils\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_sendRawTransaction } from \"../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { signTransaction } from \"../transaction/actions/sign-transaction.js\";\nimport { type Hex, toHex } from \"../utils/encoding/hex.js\";\nimport { signMessage } from \"../utils/signatures/sign-message.js\";\nimport { signTypedData } from \"../utils/signatures/sign-typed-data.js\";\nimport type { Account } from \"./interfaces/wallet.js\";\n\nexport type PrivateKeyToAccountOptions = {\n  /**\n   * A client is the entry point to the thirdweb SDK.\n   * It is required for all other actions.\n   * You can create a client using the `createThirdwebClient` function. Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   *\n   * You must provide a `clientId` or `secretKey` in order to initialize a client. Pass `clientId` if you want for client-side usage and `secretKey` for server-side usage.\n   *\n   * ```tsx\n   * import { createThirdwebClient } from \"thirdweb\";\n   *\n   * const client = createThirdwebClient({\n   *  clientId: \"<your_client_id>\",\n   * })\n   * ```\n   */\n  client: ThirdwebClient;\n\n  /**\n   * The private key to use for the account.\n   *\n   * Do not commit private key in your code and use environment variables or other secure methods to store the private key.\n   * @example\n   * ```ts\n   * const privateKey = process.env.PRIVATE_KEY;\n   * ```\n   */\n  privateKey: string;\n};\n\n/**\n * Get an `Account` object from a private key.\n * @param options - The options for `privateKeyToAccount`\n * Refer to the type [`PrivateKeyToAccountOptions`](https://portal.thirdweb.com/references/typescript/v5/PrivateKeyToAccountOptions)\n * @returns The `Account` object that represents the private key\n * @example\n * ```ts\n * import { privateKeyToAccount } from \"thirdweb/wallets\"\n *\n * const wallet = privateKeyToAccount({\n *  client,\n *  privateKey: \"...\",\n * });\n * ```\n * @wallet\n */\nexport function privateKeyToAccount(\n  options: PrivateKeyToAccountOptions,\n): Account {\n  const { client } = options;\n  const privateKey = `0x${options.privateKey.replace(/^0x/, \"\")}` satisfies Hex;\n\n  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));\n  const address = publicKeyToAddress(publicKey); // TODO: Implement publicKeyToAddress natively (will need checksumAddress downstream)\n\n  const account = {\n    address,\n    sendTransaction: async (\n      // TODO: figure out how we would pass our \"chain\" object in here?\n      // maybe we *do* actually have to take in a tx object instead of the raw tx?\n      tx: TransactionSerializable & { chainId: number },\n    ) => {\n      const rpcRequest = getRpcClient({\n        client: client,\n        chain: getCachedChain(tx.chainId),\n      });\n      const signedTx = signTransaction({\n        transaction: tx,\n        privateKey,\n      });\n      const transactionHash = await eth_sendRawTransaction(\n        rpcRequest,\n        signedTx,\n      );\n      return {\n        transactionHash,\n      };\n    },\n    signMessage: async ({ message }: { message: SignableMessage }) => {\n      return signMessage({\n        message,\n        privateKey,\n      });\n    },\n    signTypedData: async <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      _typedData: TypedDataDefinition<typedData, primaryType>,\n    ) => {\n      return signTypedData({\n        ..._typedData,\n        privateKey,\n      });\n    },\n    signTransaction: async (tx: TransactionSerializable) => {\n      return signTransaction({\n        transaction: tx,\n        privateKey,\n      });\n    },\n  };\n\n  return account satisfies Account;\n}\n", "import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport type { Account } from \"../interfaces/wallet.js\";\nimport { privateKeyToAccount } from \"../private-key.js\";\n\nexport type GenerateAccountOptions = {\n  client: ThirdwebClient;\n};\n\n/**\n * Generates a new account with a random private key.\n * @param options - The options for generating the account.\n * @param options.client - The Thirdweb client to use for the generated account.\n * @returns A Thirdweb account.\n * @example\n * ```ts\n * import { generateAccount } from \"thirdweb/wallets\";\n * const account = await generateAccount({ client });\n * ```\n * @walletUtils\n */\nexport async function generateAccount(\n  options: GenerateAccountOptions,\n): Promise<Account> {\n  const privateKey = toHex(secp256k1.utils.randomPrivateKey());\n  return privateKeyToAccount({ privateKey, client: options.client });\n}\n", "/**\n * Hide it for documentation - but expose it because we will use this to render the list of wallets in docs website\n * Using dynamic import just to be extra safe and avoid any tree shaking issues\n * @internal\n */\nexport async function getAllWalletsList() {\n  return (await import(\"./__generated__/wallet-infos.js\")).default;\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Account, Wallet } from \"../wallets/interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../wallets/wallet-emitter.js\";\n\nexport type AdapterWalletOptions = {\n  client: ThirdwebClient;\n  adaptedAccount: Account;\n  chain: Chain;\n  onDisconnect: () => Promise<void> | void;\n  switchChain: (chain: Chain) => Promise<void> | void;\n};\n\n/**\n * Creates a wallet from the given account.\n *\n * You can use this to:\n *\n * - convert a third party library wallet (wagmi, viem, ethers) into a thirdweb wallet.\n * - connect with a private key (for automated tests)\n *\n * Available wallet adatpers:\n * - [Viem](https://portal.thirdweb.com/references/typescript/v5/viemAdapter)\n * - [Ethers 6](https://portal.thirdweb.com/references/typescript/v5/ethers6Adapter)\n * - [Ethers 5](https://portal.thirdweb.com/references/typescript/v5/ethers5Adapter)\n *\n * @param options - The options for the adapter wallet.\n * @returns a wallet instance.\n *\n * @example\n * ```ts\n * import { createWalletAdapter } from \"thirdweb\";\n *\n * const wallet = createWalletAdapter({\n *  client,\n *  adaptedAccount,\n *  chain,\n *  onDisconnect: () => {\n *    // disconnect logic\n *  },\n *  switchChain: async (chain) => {\n *    // switch chain logic\n *  },\n * });\n * ```\n * @wallet\n */\nexport function createWalletAdapter(\n  options: AdapterWalletOptions,\n): Wallet<\"adapter\"> {\n  const emitter = createWalletEmitter<\"adapter\">();\n  let _chain = options.chain;\n  return {\n    id: \"adapter\",\n    subscribe: emitter.subscribe,\n    connect: async () => {\n      emitter.emit(\"onConnect\", options);\n      return options.adaptedAccount;\n    },\n    autoConnect: async () => {\n      emitter.emit(\"onConnect\", options);\n      return options.adaptedAccount;\n    },\n    disconnect: async () => {\n      await options.onDisconnect();\n      emitter.emit(\"disconnect\", undefined);\n    },\n    getAccount() {\n      return options.adaptedAccount;\n    },\n    getChain() {\n      return _chain;\n    },\n    getConfig() {\n      return options;\n    },\n    switchChain: async (chain) => {\n      await options.switchChain(chain);\n      _chain = chain;\n      emitter.emit(\"chainChanged\", chain);\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
