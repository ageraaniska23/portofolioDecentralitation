{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc721/__generated__/DropSinglePhase/read/claimCondition.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDrop/read/getActiveClaimConditionId.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDrop/read/getClaimConditionById.ts", "../../thirdweb/src/extensions/erc721/drops/read/getActiveClaimCondition.ts"],
  "sourcesContent": ["import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0xd637ed59\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"startTimestamp\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"maxClaimableSupply\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"supplyClaimed\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"quantityLimitPerWallet\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"merkleRoot\",\n    type: \"bytes32\",\n    internalType: \"bytes32\",\n  },\n  {\n    name: \"pricePerToken\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"currency\",\n    type: \"address\",\n    internalType: \"address\",\n  },\n  {\n    name: \"metadata\",\n    type: \"string\",\n    internalType: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `claimCondition` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `claimCondition` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isClaimConditionSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = await isClaimConditionSupported(contract);\n * ```\n */\nexport async function isClaimConditionSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the claimCondition function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeClaimConditionResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeClaimConditionResult(\"...\");\n * ```\n */\nexport function decodeClaimConditionResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"claimCondition\" function on the contract.\n * @param options - The options for the claimCondition function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { claimCondition } from \"thirdweb/extensions/erc721\";\n *\n * const result = await claimCondition({\n *  contract,\n * });\n *\n * ```\n */\nexport async function claimCondition(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0xc68907de\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `getActiveClaimConditionId` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `getActiveClaimConditionId` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isGetActiveClaimConditionIdSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = await isGetActiveClaimConditionIdSupported(contract);\n * ```\n */\nexport async function isGetActiveClaimConditionIdSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the getActiveClaimConditionId function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeGetActiveClaimConditionIdResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeGetActiveClaimConditionIdResult(\"...\");\n * ```\n */\nexport function decodeGetActiveClaimConditionIdResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getActiveClaimConditionId\" function on the contract.\n * @param options - The options for the getActiveClaimConditionId function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { getActiveClaimConditionId } from \"thirdweb/extensions/erc721\";\n *\n * const result = await getActiveClaimConditionId({\n *  contract,\n * });\n *\n * ```\n */\nexport async function getActiveClaimConditionId(\n  options: BaseTransactionOptions,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getClaimConditionById\" function.\n */\nexport type GetClaimConditionByIdParams = {\n  conditionId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"_conditionId\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x6f8934f4\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"_conditionId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"tuple\",\n    name: \"condition\",\n    components: [\n      {\n        type: \"uint256\",\n        name: \"startTimestamp\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxClaimableSupply\",\n      },\n      {\n        type: \"uint256\",\n        name: \"supplyClaimed\",\n      },\n      {\n        type: \"uint256\",\n        name: \"quantityLimitPerWallet\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"merkleRoot\",\n      },\n      {\n        type: \"uint256\",\n        name: \"pricePerToken\",\n      },\n      {\n        type: \"address\",\n        name: \"currency\",\n      },\n      {\n        type: \"string\",\n        name: \"metadata\",\n      },\n    ],\n  },\n] as const;\n\n/**\n * Checks if the `getClaimConditionById` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `getClaimConditionById` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isGetClaimConditionByIdSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = await isGetClaimConditionByIdSupported(contract);\n * ```\n */\nexport async function isGetClaimConditionByIdSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getClaimConditionById\" function.\n * @param options - The options for the getClaimConditionById function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeGetClaimConditionByIdParams } \"thirdweb/extensions/erc721\";\n * const result = encodeGetClaimConditionByIdParams({\n *  conditionId: ...,\n * });\n * ```\n */\nexport function encodeGetClaimConditionByIdParams(\n  options: GetClaimConditionByIdParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.conditionId]);\n}\n\n/**\n * Encodes the \"getClaimConditionById\" function into a Hex string with its parameters.\n * @param options - The options for the getClaimConditionById function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeGetClaimConditionById } \"thirdweb/extensions/erc721\";\n * const result = encodeGetClaimConditionById({\n *  conditionId: ...,\n * });\n * ```\n */\nexport function encodeGetClaimConditionById(\n  options: GetClaimConditionByIdParams,\n) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetClaimConditionByIdParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getClaimConditionById function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeGetClaimConditionByIdResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeGetClaimConditionByIdResult(\"...\");\n * ```\n */\nexport function decodeGetClaimConditionByIdResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getClaimConditionById\" function on the contract.\n * @param options - The options for the getClaimConditionById function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { getClaimConditionById } from \"thirdweb/extensions/erc721\";\n *\n * const result = await getClaimConditionById({\n *  contract,\n *  conditionId: ...,\n * });\n *\n * ```\n */\nexport async function getClaimConditionById(\n  options: BaseTransactionOptions<GetClaimConditionByIdParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.conditionId],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport type { ClaimCondition } from \"../../../../utils/extensions/drops/types.js\";\nimport { claimCondition } from \"../../__generated__/DropSinglePhase/read/claimCondition.js\";\nimport { getActiveClaimConditionId } from \"../../__generated__/IDrop/read/getActiveClaimConditionId.js\";\nimport { getClaimConditionById } from \"../../__generated__/IDrop/read/getClaimConditionById.js\";\n\n/**\n * Retrieves the active claim condition.\n * @param options - The transaction options.\n * @returns A promise that resolves to the active claim condition.\n * @throws An error if the claim condition is unsupported.\n * @extension ERC721\n * @example\n * ```ts\n * import { getActiveClaimCondition } from \"thirdweb/extensions/erc721\";\n * const activeClaimCondition = await getActiveClaimCondition({ contract });\n * ```\n */\nexport async function getActiveClaimCondition(\n  options: BaseTransactionOptions,\n): Promise<ClaimCondition> {\n  const getActiveClaimConditionMultiPhase = async () => {\n    const conditionId = await getActiveClaimConditionId(options);\n    return getClaimConditionById({ ...options, conditionId });\n  };\n  const getActiveClaimConditionSinglePhase = async () => {\n    const [\n      startTimestamp,\n      maxClaimableSupply,\n      supplyClaimed,\n      quantityLimitPerWallet,\n      merkleRoot,\n      pricePerToken,\n      currency,\n      metadata,\n    ] = await claimCondition(options);\n    return {\n      startTimestamp,\n      maxClaimableSupply,\n      supplyClaimed,\n      quantityLimitPerWallet,\n      merkleRoot,\n      pricePerToken,\n      currency,\n      metadata,\n    };\n  };\n\n  // The contract's phase type is unknown, so try both options and return whichever resolves, prioritizing multi-phase\n  const results = await Promise.allSettled([\n    getActiveClaimConditionMultiPhase(),\n    getActiveClaimConditionSinglePhase(),\n  ]);\n\n  const condition = results.find((result) => result.status === \"fulfilled\");\n  if (condition?.status === \"fulfilled\") {\n    return condition.value;\n  }\n  throw new Error(\"Claim condition not found\");\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAQO,IAAM,cAAc;AAC3B,IAAM,YAAY,CAAA;AAClB,IAAM,aAAa;EACjB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;;AAuDlB,eAAsB,eAAe,SAA+B;AAClE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAAC,aAAa,WAAW,UAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACtGO,IAAMA,eAAc;AAC3B,IAAMC,aAAY,CAAA;AAClB,IAAMC,cAAa;EACjB;IACE,MAAM;;;AAuDV,eAAsB,0BACpB,SAA+B;AAE/B,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACxDO,IAAMC,eAAc;AAC3B,IAAMC,aAAY;EAChB;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,cAAa;EACjB;IACE,MAAM;IACN,MAAM;IACN,YAAY;MACV;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;;;;AAqGd,eAAsB,sBACpB,SAA4D;AAE5D,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAC,QAAQ,WAAW;GAC7B;AACH;;;ACxJA,eAAsB,wBACpB,SAA+B;AAE/B,QAAM,oCAAoC,YAAW;AACnD,UAAM,cAAc,MAAM,0BAA0B,OAAO;AAC3D,WAAO,sBAAsB,EAAE,GAAG,SAAS,YAAW,CAAE;EAC1D;AACA,QAAM,qCAAqC,YAAW;AACpD,UAAM,CACJ,gBACA,oBACA,eACA,wBACA,YACA,eACA,UACA,QAAQ,IACN,MAAM,eAAe,OAAO;AAChC,WAAO;MACL;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;EAEJ;AAGA,QAAM,UAAU,MAAM,QAAQ,WAAW;IACvC,kCAAiC;IACjC,mCAAkC;GACnC;AAED,QAAM,YAAY,QAAQ,KAAK,CAAC,WAAW,OAAO,WAAW,WAAW;AACxE,OAAI,uCAAW,YAAW,aAAa;AACrC,WAAO,UAAU;EACnB;AACA,QAAM,IAAI,MAAM,2BAA2B;AAC7C;",
  "names": ["FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS"]
}
