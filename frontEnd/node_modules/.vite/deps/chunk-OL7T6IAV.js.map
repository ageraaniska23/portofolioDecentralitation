{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc20/__generated__/IDropERC20/write/claim.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"claim\" function.\n */\nexport type ClaimParams = WithOverrides<{\n  receiver: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"receiver\" }>;\n  quantity: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"quantity\" }>;\n  currency: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"currency\" }>;\n  pricePerToken: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"pricePerToken\";\n  }>;\n  allowlistProof: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"allowlistProof\";\n    components: [\n      { type: \"bytes32[]\"; name: \"proof\" },\n      { type: \"uint256\"; name: \"quantityLimitPerWallet\" },\n      { type: \"uint256\"; name: \"pricePerToken\" },\n      { type: \"address\"; name: \"currency\" },\n    ];\n  }>;\n  data: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"data\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x84bb1e42\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"receiver\",\n  },\n  {\n    type: \"uint256\",\n    name: \"quantity\",\n  },\n  {\n    type: \"address\",\n    name: \"currency\",\n  },\n  {\n    type: \"uint256\",\n    name: \"pricePerToken\",\n  },\n  {\n    type: \"tuple\",\n    name: \"allowlistProof\",\n    components: [\n      {\n        type: \"bytes32[]\",\n        name: \"proof\",\n      },\n      {\n        type: \"uint256\",\n        name: \"quantityLimitPerWallet\",\n      },\n      {\n        type: \"uint256\",\n        name: \"pricePerToken\",\n      },\n      {\n        type: \"address\",\n        name: \"currency\",\n      },\n    ],\n  },\n  {\n    type: \"bytes\",\n    name: \"data\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `claim` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `claim` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isClaimSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = await isClaimSupported(contract);\n * ```\n */\nexport async function isClaimSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"claim\" function.\n * @param options - The options for the claim function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeClaimParams } \"thirdweb/extensions/erc20\";\n * const result = encodeClaimParams({\n *  receiver: ...,\n *  quantity: ...,\n *  currency: ...,\n *  pricePerToken: ...,\n *  allowlistProof: ...,\n *  data: ...,\n * });\n * ```\n */\nexport function encodeClaimParams(options: ClaimParams) {\n  return encodeAbiParameters(FN_INPUTS, [\n    options.receiver,\n    options.quantity,\n    options.currency,\n    options.pricePerToken,\n    options.allowlistProof,\n    options.data,\n  ]);\n}\n\n/**\n * Encodes the \"claim\" function into a Hex string with its parameters.\n * @param options - The options for the claim function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeClaim } \"thirdweb/extensions/erc20\";\n * const result = encodeClaim({\n *  receiver: ...,\n *  quantity: ...,\n *  currency: ...,\n *  pricePerToken: ...,\n *  allowlistProof: ...,\n *  data: ...,\n * });\n * ```\n */\nexport function encodeClaim(options: ClaimParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeClaimParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"claim\" function on the contract.\n * @param options - The options for the \"claim\" function.\n * @returns A prepared transaction object.\n * @extension ERC20\n * @example\n * ```ts\n * import { claim } from \"thirdweb/extensions/erc20\";\n *\n * const transaction = claim({\n *  contract,\n *  receiver: ...,\n *  quantity: ...,\n *  currency: ...,\n *  pricePerToken: ...,\n *  allowlistProof: ...,\n *  data: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * ...\n *\n * ```\n */\nexport function claim(\n  options: BaseTransactionOptions<\n    | ClaimParams\n    | {\n        asyncParams: () => Promise<ClaimParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [\n        resolvedOptions.receiver,\n        resolvedOptions.quantity,\n        resolvedOptions.currency,\n        resolvedOptions.pricePerToken,\n        resolvedOptions.allowlistProof,\n        resolvedOptions.data,\n      ] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;AAmCO,IAAM,cAAc;AAC3B,IAAM,YAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;IACN,YAAY;MACV;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;;;EAIZ;IACE,MAAM;IACN,MAAM;;;AAGV,IAAM,aAAa,CAAA;AAcnB,eAAsB,iBAAiB,UAA+B;AACpE,SAAO,aAAa;IAClB;IACA,QAAQ,CAAC,aAAa,WAAW,UAAU;GAC5C;AACH;AAoBM,SAAU,kBAAkB,SAAoB;AACpD,SAAO,oBAAoB,WAAW;IACpC,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;GACT;AACH;AAoBM,SAAU,YAAY,SAAoB;AAG9C,SAAQ,cACN,kBAAkB,OAAO,EAAE,MAAM,CAAC;AACtC;AA6BM,SAAU,MACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,UAAU,QAAQ;IAClB,QAAQ,CAAC,aAAa,WAAW,UAAU;IAC3C,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO;QACL,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;;IAEpB;IACA,OAAO,YAAS;AA3MpB;AA2MwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,YAAY,YAAS;AA5MzB;AA4M6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,KAAK,YAAS;AA7MlB;AA6MsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AA9MvB;AA8M2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AA/M3B;AA+M+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAhNnC;AAiNO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,OAAO,YAAS;AAlNpB;AAkNwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,UAAU,YAAS;AAnNvB;AAmN2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,YAAY,YAAS;AApNzB;AAoN6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GAC3D;AACH;",
  "names": []
}
