{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/hashing/sha256.ts", "../../thirdweb/src/utils/client-id.ts", "../../thirdweb/src/client/client.ts", "../../thirdweb/src/rpc/actions/eth_getBlockByHash.ts", "../../thirdweb/src/rpc/actions/eth_getTransactionByHash.ts", "../../thirdweb/src/transaction/resolve-method.ts", "../../thirdweb/src/utils/encoding/from-bytes.ts", "../../thirdweb/src/auth/constants.ts", "../../thirdweb/src/auth/is-erc6492-signature.ts", "../../thirdweb/src/auth/serialize-erc6492-signature.ts", "../../thirdweb/src/auth/verify-hash.ts", "../../thirdweb/src/auth/verify-typed-data.ts"],
  "sourcesContent": ["import { sha256 as noble_sha256 } from \"@noble/hashes/sha256\";\nimport {\n  type Hex,\n  hexToUint8Array,\n  isHex,\n  uint8ArrayToHex,\n} from \"../encoding/hex.js\";\n\ntype To = \"hex\" | \"bytes\";\n\nexport type Sha256Hash<TTo extends To> =\n  | (TTo extends \"bytes\" ? Uint8Array : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Calculates the SHA256 hash of the given value.\n * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.\n * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.\n * @returns The SHA256 hash of the value in the specified format.\n * @example\n * ```ts\n * import { sha256 } from \"thirdweb/utils\";\n * const hash = sha256(\"0x1234\");\n * ```\n * @utils\n */\nexport function sha256<TTo extends To = \"hex\">(\n  value: Hex | Uint8Array,\n  to?: TTo,\n): Sha256Hash<TTo> {\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\n  );\n  if (to === \"bytes\") {\n    return bytes as Sha256Hash<TTo>;\n  }\n  return uint8ArrayToHex(bytes) as Sha256Hash<TTo>;\n}\n", "import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { sha256 } from \"./hashing/sha256.js\";\n\nconst cache = new LruMap<string>(4096);\n\n/**\n * @param secretKey - the secret key to compute the client id from\n * @returns the 32 char hex client id\n * @internal\n */\nexport function computeClientIdFromSecretKey(secretKey: string): string {\n  if (cache.has(secretKey)) {\n    return cache.get(secretKey) as string;\n  }\n  // we slice off the leading `0x` and then take the first 32 chars\n  const cId = sha256(stringToBytes(secretKey)).slice(2, 34);\n  cache.set(secretKey, cId);\n  return cId;\n}\n", "import { computeClientIdFromSecretKey } from \"../utils/client-id.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\ntype FetchConfig = {\n  requestTimeoutMs?: number;\n  keepalive?: boolean;\n  headers?: HeadersInit;\n};\n\ntype ClientOptions = Prettify<{\n  /**\n   * The configuration options for the client.\n   */\n  config?: {\n    /**\n     * The configuration options for the RPC client.\n     */\n    rpc?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The maximum number of requests to batch together.\n       * @default 100\n       */\n      maxBatchSize?: number;\n      /**\n       * The maximum time to wait before sending a batch of requests.\n       * @default 0 (no timeout)\n       */\n      batchTimeoutMs?: number;\n    };\n    /**\n     * The configuration options for the storage client.\n     */\n    storage?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The IPFS gateway URL.\n       * @default \"https://<your_client_id>.ipfscdn.io/ipfs/<cid>\"\n       */\n      gatewayUrl?: string;\n    };\n  };\n}>;\n\nexport type CreateThirdwebClientOptions = Prettify<\n  (\n    | {\n        clientId: string;\n        secretKey?: never;\n      }\n    | {\n        clientId?: never;\n        secretKey: string;\n      }\n  ) &\n    ClientOptions\n>;\n\nexport type ThirdwebClient = {\n  readonly clientId: string;\n  readonly secretKey: string | undefined;\n} & Readonly<ClientOptions>;\n\n/**\n * Creates a Thirdweb client using the provided client ID (client-side) or secret key (server-side).\n *\n * Get your client ID and secret key from the Thirdweb dashboard [here](https://thirdweb.com/dashboard/settings/api-keys).\n * **Never share your secret key with anyone.\n *\n * A client is necessary for most functions in the thirdweb SDK. It provides access to thirdweb APIs including built-in RPC, storage, and more.\n *\n * @param options - The options for creating the client.\n * @param [options.clientId] - The client ID to use for thirdweb services.\n * @param [options.secretKey] - The secret key to use for thirdweb services.\n * @returns The created Thirdweb client.\n * @throws An error if neither `clientId` nor `secretKey` is provided.\n *\n * @example\n * Create a client on the client side (client ID):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * ```\n *\n * Create a client on the server (secret key):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ secretKey: \"...\" });\n * ```\n */\nexport function createThirdwebClient(\n  options: CreateThirdwebClientOptions,\n): ThirdwebClient {\n  const { clientId, secretKey, ...rest } = options;\n  // if secretKey is provided, compute the clientId from it (and ignore any clientId passed in)\n  if (secretKey) {\n    return {\n      ...rest,\n      clientId: computeClientIdFromSecretKey(secretKey),\n      secretKey,\n    } as const;\n  }\n  // otherwise if clientId is provided, use it\n  if (clientId) {\n    return {\n      ...rest,\n      clientId: options.clientId,\n      secretKey: undefined,\n    } as const;\n  }\n\n  // otherwise throw an error\n  throw new Error(\"clientId or secretKey must be provided\");\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type GetBlockReturnType,\n  type Hash,\n  formatBlock,\n} from \"viem\";\n\ntype GetBlockByHashParams<TIncludeTransactions extends boolean = false> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & {\n  /** Hash of the block. */\n  blockHash: Hash;\n};\n\n/**\n * Retrieves a block by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the block retrieval.\n * @returns A promise that resolves to the retrieved block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByHash(rpcRequest, {\n * blockHash: \"0x...\",\n * includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByHash<\n  TIncludeTransactions extends boolean = false,\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockByHashParams<TIncludeTransactions>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions>> {\n  const includeTransactions = params.includeTransactions ?? false;\n\n  const block = await request({\n    method: \"eth_getBlockByHash\",\n    params: [params.blockHash, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions\n  >;\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type Hash,\n  type Transaction,\n  formatTransaction,\n} from \"viem\";\n\ntype GetTransactionByHashParameters = {\n  hash: Hash;\n};\n\n/**\n * Retrieves a transaction by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction.\n * @returns A promise that resolves to the transaction.\n * @throws An error if the transaction is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n *  const transaction = await eth_getTransactionByHash(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionByHash(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionByHashParameters,\n): Promise<Transaction> {\n  const receipt = await request({\n    method: \"eth_getTransactionByHash\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction not found.\");\n  }\n\n  return formatTransaction(receipt);\n}\n", "import type { Abi, AbiFunction } from \"abitype\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\n\n/**\n * Resolves and returns the ABI function with the specified method name.\n * Throws an error if the function is not found in the ABI.\n * @template abiFn - The type of the ABI function.\n * @param method - The name of the method to resolve.\n * @returns The resolved ABI function.\n * @throws Error if the function is not found in the ABI.\n * @example\n * ```ts\n * import { resolveMethod, prepareContractCall } from \"thirdweb\";\n * const tx = prepareContractCall({\n *  contract,\n *  // automatically resolves the necessary abi to encode the transaction\n *  method: resolveMethod(\"transfer\"),\n *  // however there is no type completion for params in this case (as the resolution is async and happens at runtime)\n *  params: [to, value],\n * });\n * ```\n * @contract\n */\nexport function resolveMethod<abiFn extends AbiFunction>(method: string) {\n  return async (contract: ThirdwebContract) => {\n    const resolvedAbi = await resolveContractAbi<Abi>(contract);\n    // we try to find the abiFunction in the abi\n    const abiFunction = resolvedAbi.find((item) => {\n      // if the item is not a function we can ignore it\n      if (item.type !== \"function\") {\n        return false;\n      }\n      // if the item is a function we can compare the name\n      return item.name === method;\n    }) as abiFn | undefined;\n\n    if (!abiFunction) {\n      throw new Error(`could not find function with name \"${method}\" in abi`);\n    }\n    return abiFunction;\n  };\n}\n", "import { assertSize } from \"./helpers/assert-size.js\";\nimport type { Hex } from \"./helpers/is-hex.js\";\nimport { trim } from \"./helpers/trim.js\";\nimport { hexToBigInt, hexToNumber, uint8ArrayToHex } from \"./hex.js\";\n\nexport type FromBytesParameters<\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\n> =\n  | TTo\n  | {\n      /** Size of the bytes. */\n      size?: number;\n      /** Type to convert to. */\n      to: TTo;\n    };\n\nexport type FromBytesReturnType<TTo> = TTo extends \"string\"\n  ? string\n  : TTo extends \"hex\"\n    ? Hex\n    : TTo extends \"bigint\"\n      ? bigint\n      : TTo extends \"number\"\n        ? number\n        : TTo extends \"boolean\"\n          ? boolean\n          : never;\n\n/**\n * Converts a Uint8Array to the specified type.\n * @param bytes - The Uint8Array to convert.\n * @param toOrOpts - The target type or conversion options.\n * @returns The converted value of the specified type.\n * @example\n * ```ts\n * import { fromBytes } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = fromBytes(bytes, \"number\");\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function fromBytes<\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\n>(\n  bytes: Uint8Array,\n  toOrOpts: FromBytesParameters<TTo>,\n): FromBytesReturnType<TTo> {\n  const opts = typeof toOrOpts === \"string\" ? { to: toOrOpts } : toOrOpts;\n  switch (opts.to) {\n    case \"number\":\n      return bytesToNumber(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"bigint\":\n      return bytesToBigInt(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"boolean\":\n      return bytesToBool(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"string\":\n      return bytesToString(bytes, opts) as FromBytesReturnType<TTo>;\n    default:\n      return uint8ArrayToHex(bytes, opts) as FromBytesReturnType<TTo>;\n  }\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean;\n  /** Size of the bytes. */\n  size?: number;\n};\n\n/**\n * Converts a Uint8Array of bytes to a bigint.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The converted bigint.\n * @example\n * ```ts\n * import { bytesToBigInt } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const bigInt = bytesToBigInt(bytes);\n * console.log(bigInt); // 420n\n * ```\n * @utils\n */\nexport function bytesToBigInt(\n  bytes: Uint8Array,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n  }\n  const hex = uint8ArrayToHex(bytes, opts);\n  return hexToBigInt(hex, opts);\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number;\n};\n\n/**\n * Converts a byte array to a boolean value.\n * @param bytes_ - The byte array to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The boolean value converted from the byte array.\n * @throws Error if the byte array is invalid or the boolean representation is invalid.\n * @example\n * ```ts\n * import { bytesToBool } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1]);\n * const bool = bytesToBool(bytes);\n * console.log(bool); // true\n * ```\n * @utils\n */\nexport function bytesToBool(\n  bytes_: Uint8Array,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_;\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n    bytes = trim(bytes);\n  }\n\n  if (bytes.length > 1 || (bytes[0] && bytes[0] > 1)) {\n    throw new Error(`Invalid boolean representation: ${bytes}`);\n  }\n  return Boolean(bytes[0]);\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts;\n\n/**\n * Converts a Uint8Array of bytes to a number.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional configuration options.\n * @returns The converted number.\n * @example\n * ```ts\n * import { bytesToNumber } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = bytesToNumber(bytes);\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function bytesToNumber(\n  bytes: Uint8Array,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n  }\n  const hex = uint8ArrayToHex(bytes, opts);\n  return hexToNumber(hex, opts);\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number;\n};\n\n/**\n * Converts an array of bytes to a string using UTF-8 encoding.\n * @param bytes_ - The array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The resulting string.\n * @example\n * ```ts\n * import { bytesToString } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]);\n * const string = bytesToString(bytes);\n * console.log(string); // \"Hello\"\n * ```\n * @utils\n */\nexport function bytesToString(\n  bytes_: Uint8Array,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_;\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n    bytes = trim(bytes, { dir: \"right\" });\n  }\n  return new TextDecoder().decode(bytes);\n}\n", "export const ERC_6492_MAGIC_VALUE =\n  \"0x6492649264926492649264926492649264926492649264926492649264926492\" as const;\n\n// returns either 0x1 (valid) or 0x0 (invalid)\nexport const universalSignatureValidatorAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_signer\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_hash\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_signature\",\n        type: \"bytes\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n] as const;\n\nexport const universalSignatureValidatorByteCode =\n  \"0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572\";\n", "import { sliceHex } from \"viem\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\n\n/**\n * @description Determines if a signature is compatible with [ERC6492](https://eips.ethereum.org/EIPS/eip-6492)\n *\n * @param {Hex} signature The signature to check for ERC6492 compatibility\n *\n * @returns {boolean} True if the signature is compatible with ERC6492, false otherwise\n *\n * @example\n * ```ts\n * import { isErc6492Signature } from 'thirdweb/auth';\n *\n * const isErc6492 = isErc6492Signature('0x1234567890123456789012345678901234567890');\n * ```\n *\n * @auth\n */\nexport function isErc6492Signature(signature: Hex): boolean {\n  return sliceHex(signature, -32) === ERC_6492_MAGIC_VALUE;\n}\n", "import { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { concatHex } from \"../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\nimport type { Erc6492Signature } from \"./types.js\";\n\n/**\n * @description Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.\n *\n * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format\n * @param {string} signature.address The ERC-4337 Account Factory address\n * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification\n * @param {Hex} signature.signature The original signature\n *\n * @returns {Hex} The serialized signature\n *\n * @example\n * ```ts\n * import { serializeErc6492Signature } from 'thirdweb/auth';\n *\n * const serializedSignature = serializeErc6492Signature({\n *  address: '0x...',\n *  data: '0x...',\n *  signature: '0x...',\n * });\n * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492\n * ```\n * @auth\n */\nexport function serializeErc6492Signature({\n  address,\n  data,\n  signature,\n}: Erc6492Signature): Hex {\n  return concatHex([\n    encodeAbiParameters(\n      [{ type: \"address\" }, { type: \"bytes\" }, { type: \"bytes\" }],\n      [address, data, signature],\n    ),\n    ERC_6492_MAGIC_VALUE,\n  ]);\n}\n", "import { equalBytes } from \"@noble/curves/abstract/utils\";\nimport { type Signature, encodeDeployData, serializeSignature } from \"viem\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { type Hex, isHex } from \"../utils/encoding/hex.js\";\nimport { toBytes } from \"../utils/encoding/to-bytes.js\";\nimport {\n  universalSignatureValidatorAbi,\n  universalSignatureValidatorByteCode,\n} from \"./constants.js\";\nimport { isErc6492Signature } from \"./is-erc6492-signature.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\n\nexport type VerifyHashParams = {\n  hash: Hex;\n  signature: string | Uint8Array | Signature;\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  accountFactory?: {\n    address: string;\n    verificationCalldata: Hex;\n  };\n};\n\n/**\n * @description Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash({\n  hash,\n  signature,\n  address,\n  client,\n  chain,\n  accountFactory,\n}: VerifyHashParams): Promise<boolean> {\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\n      return serializeSignature(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\n    // We should never hit this but TS doesn't know that\n    throw new Error(\n      `Invalid signature type for signature ${signature}: ${typeof signature}`,\n    );\n  })();\n\n  const wrappedSignature = await (async () => {\n    // If no factory is provided, we have to assume its already deployed or is an EOA\n    // TODO: Figure out how to automatically tell if our default factory was used\n    if (!accountFactory) return signatureHex;\n\n    // If this sigature was already wrapped for ERC-6492, carry on\n    if (isErc6492Signature(signatureHex)) return signatureHex;\n\n    // Otherwise, serialize the signature for ERC-6492 validation\n    return serializeErc6492Signature({\n      address: accountFactory.address,\n      data: accountFactory.verificationCalldata,\n      signature: signatureHex,\n    });\n  })();\n\n  const verificationData = encodeDeployData({\n    abi: universalSignatureValidatorAbi,\n    args: [address, hash, wrappedSignature],\n    bytecode: universalSignatureValidatorByteCode,\n  });\n\n  const rpcRequest = getRpcClient({\n    chain,\n    client,\n  });\n\n  try {\n    const result = await eth_call(rpcRequest, {\n      data: verificationData,\n    });\n\n    const hexResult = isHex(result) ? toBytes(result) : result;\n    return equalBytes(hexResult, toBytes(\"0x1\"));\n  } catch (error) {\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n    // Verification failed somehow\n    return false;\n  }\n}\n", "import type { Signature, TypedData, TypedDataDefinition } from \"viem\";\nimport { hashTypedData } from \"viem\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { HashTypedDataParams } from \"../utils/hashing/hashTypedData.js\";\nimport { type VerifyHashParams, verifyHash } from \"./verify-hash.js\";\n\nexport type VerifyTypedDataParams<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = Omit<VerifyHashParams, \"hash\"> &\n  TypedDataDefinition<typedData, primaryType> & {\n    address: string;\n    signature: string | Uint8Array | Signature;\n    client: ThirdwebClient;\n    chain: Chain;\n    accountFactory?: {\n      address: string;\n      verificationCalldata: Hex;\n    };\n  };\n\n/**\n * @description Verify am [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data signature. This function is interoperable with all wallet types (smart accounts or EOAs).\n *\n * @param {string} options.address The address that signed the typed data\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n * @param {typeof VerifyTypedDataParams.message} options.message The EIP-712 message that was signed.\n * @param {typeof VerifyTypedDataParams.domain} options.domain The EIP-712 domain that was signed.\n * @param {typeof VerifyTypedDataParams.primaryType} options.primaryType The EIP-712 primary type that was signed.\n * @param {typeof VerifyTypedDataParams.types} options.types The EIP-712 types that were signed.\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n * \n * @example\n * ```ts\n * import { verifyTypedData } from \"thirdweb/utils\";\n * const isValid = await verifyTypedData({\n *   address: \"0x...\",\n *   signature: \"0x...\",\n *   client,\n *   chain,\n *   domain: {\n      name: \"Ether Mail\",\n      version: \"1\",\n      chainId: 1,\n      verifyingContract: \"0x0000000000000000000000000000000000000000\",\n    },\n *   primaryType: \"Mail\",\n *   types: {\n      Person: [\n        { name: \"name\", type: \"string\" },\n        { name: \"wallet\", type: \"address\" },\n      ],\n      Mail: [\n        { name: \"from\", type: \"Person\" },\n        { name: \"to\", type: \"Person\" },\n        { name: \"contents\", type: \"string\" },\n      ],\n    },\n    message: {\n      from: {\n        name: \"Cow\",\n        wallet: \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n      },\n      to: {\n        name: \"Bob\",\n        wallet: \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n      },\n      contents: \"Hello, Bob!\",\n    },\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyTypedData<\n  typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>({\n  address,\n  signature,\n  client,\n  chain,\n  accountFactory,\n  message,\n  domain,\n  primaryType,\n  types,\n}: VerifyTypedDataParams<typedData, primaryType>): Promise<boolean> {\n  const messageHash = hashTypedData({\n    message,\n    domain,\n    primaryType,\n    types,\n  } as HashTypedDataParams);\n  return verifyHash({\n    hash: messageHash,\n    signature,\n    address,\n    chain,\n    client,\n    accountFactory,\n  });\n}\n"],
  "mappings": "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",
  "names": ["sha256", "sha256"]
}
