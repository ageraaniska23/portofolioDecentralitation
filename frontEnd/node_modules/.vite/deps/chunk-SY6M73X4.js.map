{
  "version": 3,
  "sources": ["../../thirdweb/src/rpc/actions/eth_getStorageAt.ts", "../../thirdweb/src/utils/bytecode/extractMnimalProxyImplementationAddress.ts", "../../thirdweb/src/utils/bytecode/resolveImplementation.ts", "../../thirdweb/src/utils/bytecode/detectExtension.ts"],
  "sourcesContent": ["import type { BlockTag, EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\ntype GetStorageAtParams = {\n  address: string;\n  position: Hex;\n  blockTag?: BlockTag;\n};\n\n/**\n * Retrieves the value stored at a specific position in the storage of a contract.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the eth_getStorageAt method.\n * @returns A promise that resolves to the value stored at the specified position.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getStorageAt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const storageValue = await eth_getStorageAt(rpcRequest, {\n * address: \"0x...\",\n *  position: 0n,\n * });\n * ```\n */\nexport async function eth_getStorageAt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetStorageAtParams,\n): Promise<Hex> {\n  return await request({\n    method: \"eth_getStorageAt\",\n    params: [params.address, params.position, params.blockTag ?? \"latest\"],\n  });\n}\n", "/**\n * Extracts the implementation address from a given bytecode string if it matches any of the known minimal proxy patterns.\n * @param bytecode The bytecode string to extract the implementation address from.\n * @returns The implementation address as a string if a match is found, otherwise undefined.\n * @example\n * ```ts\n * import { extractMinimalProxyImplementationAddress } from \"thirdweb/utils\";\n * const bytecode = \"0x363d3d373d3d3d363d73...\";\n * const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n * ```\n * @utils\n */\nexport function extractMinimalProxyImplementationAddress(\n  bytecode: string,\n): string | undefined {\n  if (!bytecode.startsWith(\"0x\")) {\n    // biome-ignore lint/style/noParameterAssign: perf\n    bytecode = `0x${bytecode}`;\n  }\n  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n  if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n    const implementationAddress = bytecode.slice(22, 62);\n    return `0x${implementationAddress}`;\n  }\n\n  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n  if (bytecode.startsWith(\"0x36603057343d5230\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(122, 122 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n  if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(24, 24 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n  if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n    const implementationAddress = bytecode.slice(32, 32 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  if (bytecode.startsWith(\"0x36600080376020600036600073\")) {\n    const implementationAddress = bytecode.slice(28, 28 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // EIP-7511 minimal proxy with PUSH0 opcode - https://eips.ethereum.org/EIPS/eip-7511\n  if (bytecode.startsWith(\"0x365f5f375f5f365f73\")) {\n    const implementationAddress = bytecode.slice(20, 60);\n    return `0x${implementationAddress}`;\n  }\n\n  return undefined;\n}\n", "import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMnimalProxyImplementationAddress.js\";\n\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<{ address: string; bytecode: string }> {\n  const [originalBytecode, beacon] = await Promise.all([\n    getBytecode(contract),\n    getBeaconFromStorageSlot(contract),\n  ]);\n  // check minimal proxy first synchronously\n  const minimalProxyImplementationAddress =\n    extractMinimalProxyImplementationAddress(originalBytecode);\n  if (minimalProxyImplementationAddress) {\n    return {\n      address: minimalProxyImplementationAddress,\n      bytecode: await getBytecode({\n        ...contract,\n        address: minimalProxyImplementationAddress,\n      }),\n    };\n  }\n\n  // check other proxy types\n  let implementationAddress: string | undefined;\n  if (beacon && beacon !== AddressZero) {\n    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n    // Hence we replace the proxy address with Beacon address, and continue further resolving below\n    // biome-ignore lint/style/noParameterAssign: we purposefully mutate the contract object here\n    contract = { ...contract, address: beacon };\n\n    implementationAddress = await getImplementationFromContractCall(contract);\n  } else {\n    implementationAddress = await getImplementationFromStorageSlot(contract);\n  }\n\n  if (\n    implementationAddress &&\n    isAddress(implementationAddress) &&\n    implementationAddress !== AddressZero\n  ) {\n    const implementationBytecode = await getBytecode({\n      ...contract,\n      address: implementationAddress,\n    });\n    // return the original contract bytecode if the implementation bytecode is empty\n    if (implementationBytecode === \"0x\") {\n      return {\n        address: contract.address,\n        bytecode: originalBytecode,\n      };\n    }\n\n    return {\n      address: implementationAddress,\n      bytecode: implementationBytecode,\n    };\n  }\n\n  return { address: contract.address, bytecode: originalBytecode };\n}\n\nasync function getBeaconFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  /**\n   * The storage slot of the Beacon as defined in EIP-1967\n   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n   *\n   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n   */\n  const rpcRequest = getRpcClient({\n    client: contract.client,\n    chain: contract.chain,\n  });\n\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n        \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\",\n    });\n    return `0x${proxyStorage.slice(-40)}`;\n  } catch {\n    return undefined;\n  }\n}\n\nasync function getImplementationFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  const rpcRequest = getRpcClient({\n    client: contract.client,\n    chain: contract.chain,\n  });\n\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n        \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n    });\n    return `0x${proxyStorage.slice(-40)}`;\n  } catch {\n    return undefined;\n  }\n}\n\nconst UPGRADEABLE_PROXY_ABI = {\n  type: \"function\",\n  name: \"implementation\",\n  inputs: [],\n  outputs: [\n    {\n      type: \"address\",\n      name: \"\",\n      internalType: \"address\",\n    },\n  ],\n  stateMutability: \"view\",\n} as const;\n\nasync function getImplementationFromContractCall(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  try {\n    return await readContract({ contract, method: UPGRADEABLE_PROXY_ABI });\n  } catch {\n    return undefined;\n  }\n}\n", "import type { AbiFunction } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedMethod } from \"../abi/prepare-method.js\";\nimport { resolveImplementation } from \"./resolveImplementation.js\";\n\ntype DetectExtensionOptions = {\n  contract: ThirdwebContract;\n  method: string | AbiFunction | PreparedMethod<AbiFunction>;\n};\n\n/**\n * Detects if the specified method is present in the contract bytecode.\n * @param options - The options for detecting the extension.\n * @returns A promise that resolves to a boolean indicating if the extension is detected.\n * @example\n * ```ts\n * import { detectMethod } from \"thirdweb/utils/extensions/detect.js\";\n * const hasDecimals = await detectMethod({\n *  contract,\n *  method: \"function decimals() view returns (uint8)\",\n * });\n * ```\n * @contract\n */\nexport async function detectMethod(\n  options: DetectExtensionOptions,\n): Promise<boolean> {\n  const { bytecode } = await resolveImplementation(options.contract);\n  return detectMethodInBytecode({ bytecode, method: options.method });\n}\n\ntype DetectExtensionInBytecodeOptions = {\n  bytecode: string;\n  method: string | AbiFunction | PreparedMethod<AbiFunction>;\n};\n/**\n * Detects if a specific method is present in the bytecode of a contract.\n * @param options - The options for detecting the method in the bytecode.\n * @returns A boolean indicating whether the method is present in the bytecode.\n * @internal\n */\nfunction detectMethodInBytecode(options: DetectExtensionInBytecodeOptions) {\n  // if we can't get the bytecode we know the contract is not deployed\n  if (options.bytecode === \"0x\") {\n    return false;\n  }\n  // we strip the leading `0x` from the function selector\n  const fnSelector = Array.isArray(options.method)\n    ? options.method[0]\n    : toFunctionSelector(options.method);\n\n  // indexOf is slightly faster than includes\n  return options.bytecode.indexOf(fnSelector.slice(2)) > -1;\n}\n"],
  "mappings": "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",
  "names": []
}
