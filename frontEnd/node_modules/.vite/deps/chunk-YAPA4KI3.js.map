{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc20/__generated__/IERC20/write/approve.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"approve\" function.\n */\nexport type ApproveParams = WithOverrides<{\n  spender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"spender\" }>;\n  value: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"value\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x095ea7b3\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"spender\",\n  },\n  {\n    type: \"uint256\",\n    name: \"value\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bool\",\n  },\n] as const;\n\n/**\n * Checks if the `approve` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `approve` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isApproveSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = await isApproveSupported(contract);\n * ```\n */\nexport async function isApproveSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"approve\" function.\n * @param options - The options for the approve function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeApproveParams } \"thirdweb/extensions/erc20\";\n * const result = encodeApproveParams({\n *  spender: ...,\n *  value: ...,\n * });\n * ```\n */\nexport function encodeApproveParams(options: ApproveParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.spender, options.value]);\n}\n\n/**\n * Encodes the \"approve\" function into a Hex string with its parameters.\n * @param options - The options for the approve function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeApprove } \"thirdweb/extensions/erc20\";\n * const result = encodeApprove({\n *  spender: ...,\n *  value: ...,\n * });\n * ```\n */\nexport function encodeApprove(options: ApproveParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeApproveParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"approve\" function on the contract.\n * @param options - The options for the \"approve\" function.\n * @returns A prepared transaction object.\n * @extension ERC20\n * @example\n * ```ts\n * import { approve } from \"thirdweb/extensions/erc20\";\n *\n * const transaction = approve({\n *  contract,\n *  spender: ...,\n *  value: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * ...\n *\n * ```\n */\nexport function approve(\n  options: BaseTransactionOptions<\n    | ApproveParams\n    | {\n        asyncParams: () => Promise<ApproveParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.spender, resolvedOptions.value] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n  });\n}\n"],
  "mappings": ";;;;;;AAmBO,IAAM,cAAc;AAC3B,IAAM,YAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAM,aAAa;EACjB;IACE,MAAM;;;AAqFJ,SAAU,QACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,UAAU,QAAQ;IAClB,QAAQ,CAAC,aAAa,WAAW,UAAU;IAC3C,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,SAAS,gBAAgB,KAAK;IACxD;IACA,OAAO,YAAS;AAnIpB;AAmIwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,YAAY,YAAS;AApIzB;AAoI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,KAAK,YAAS;AArIlB;AAqIsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AAtIvB;AAsI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAvI3B;AAuI+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAxInC;AAyIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,OAAO,YAAS;AA1IpB;AA0IwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,UAAU,YAAS;AA3IvB;AA2I2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,YAAY,YAAS;AA5IzB;AA4I6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GAC3D;AACH;",
  "names": []
}
