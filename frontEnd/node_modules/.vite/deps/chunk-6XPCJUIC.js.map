{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/common/__generated__/IContractMetadata/read/name.ts", "../../thirdweb/src/extensions/common/read/name.ts", "../../thirdweb/src/extensions/common/__generated__/IContractMetadata/read/symbol.ts", "../../thirdweb/src/extensions/common/read/symbol.ts"],
  "sourcesContent": ["import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x06fdde03\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `name` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `name` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isNameSupported } from \"thirdweb/extensions/common\";\n *\n * const supported = await isNameSupported(contract);\n * ```\n */\nexport async function isNameSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the name function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeNameResult } from \"thirdweb/extensions/common\";\n * const result = decodeNameResult(\"...\");\n * ```\n */\nexport function decodeNameResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"name\" function on the contract.\n * @param options - The options for the name function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const result = await name({\n *  contract,\n * });\n *\n * ```\n */\nexport async function name(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { name as generatedName } from \"../__generated__/IContractMetadata/read/name.js\";\n\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const contractName = await name({ contract });\n * ```\n */\nexport async function name(options: BaseTransactionOptions): Promise<string> {\n  return withCache(() => generatedName(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:name`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n", "import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x95d89b41\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `symbol` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `symbol` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isSymbolSupported } from \"thirdweb/extensions/common\";\n *\n * const supported = await isSymbolSupported(contract);\n * ```\n */\nexport async function isSymbolSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the symbol function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeSymbolResult } from \"thirdweb/extensions/common\";\n * const result = decodeSymbolResult(\"...\");\n * ```\n */\nexport function decodeSymbolResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"symbol\" function on the contract.\n * @param options - The options for the symbol function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const result = await symbol({\n *  contract,\n * });\n *\n * ```\n */\nexport async function symbol(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { symbol as generatedSymbol } from \"../__generated__/IContractMetadata/read/symbol.js\";\n\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const contractSymbol = await symbol({ contract });\n * ```\n */\nexport async function symbol(options: BaseTransactionOptions): Promise<string> {\n  return withCache(() => generatedSymbol(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:symbol`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n"],
  "mappings": ";;;;;;;;AAQO,IAAM,cAAc;AAC3B,IAAM,YAAY,CAAA;AAClB,IAAM,aAAa;EACjB;IACE,MAAM;;;AAqDV,eAAsB,KAAK,SAA+B;AACxD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAAC,aAAa,WAAW,UAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACvDA,eAAsBA,MAAK,SAA+B;AACxD,SAAO,UAAU,MAAM,KAAc,OAAO,GAAG;IAC7C,UAAU,GAAG,QAAQ,SAAS,MAAM,EAAE,IAAI,QAAQ,SAAS,OAAO;;IAElE,WAAW,OAAO;GACnB;AACH;;;ACdO,IAAMC,eAAc;AAC3B,IAAMC,aAAY,CAAA;AAClB,IAAMC,cAAa;EACjB;IACE,MAAM;;;AAqDV,eAAsB,OAAO,SAA+B;AAC1D,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACvDA,eAAsBC,QAAO,SAA+B;AAC1D,SAAO,UAAU,MAAM,OAAgB,OAAO,GAAG;IAC/C,UAAU,GAAG,QAAQ,SAAS,MAAM,EAAE,IAAI,QAAQ,SAAS,OAAO;;IAElE,WAAW,OAAO;GACnB;AACH;",
  "names": ["name", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "symbol"]
}
