import {
  assertTransactionEIP1559,
  assertTransactionEIP2930,
  assertTransactionLegacy,
  serializeAccessList,
  serializeTransaction,
  toRlp
} from "./chunk-JMJMW6FX.js";
import {
  keccak256
} from "./chunk-CY3CMUVN.js";
import {
  toHex
} from "./chunk-BNK74YTA.js";
import {
  secp256k1
} from "./chunk-L46BJXKD.js";

// node_modules/thirdweb/dist/esm/utils/encoding/helpers/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") {
      sliceLength++;
    } else {
      break;
    }
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right") {
      data = `${data}0`;
    }
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

// node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js
function serializeTransaction2(options) {
  const { transaction } = options;
  if (transaction.type === "eip4844" || // explicit type checks required for viem parity
  typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined") {
    return serializeTransaction(transaction);
  }
  if (transaction.type === "eip1559" || typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return serializeEIP1559Transaction({
      transaction
    });
  }
  if (transaction.type === "eip2930" || typeof transaction.gasPrice !== "undefined" && typeof transaction.accessList !== "undefined") {
    return serializeEIP2930Transaction({
      transaction
    });
  }
  if (transaction.type === "legacy" || typeof transaction.gasPrice !== "undefined") {
    return serializeTransactionLegacy({
      transaction
    });
  }
  throw new Error(`Invalid transaction to serialize.

${JSON.stringify(transaction, (_, v) => typeof v === "bigint" ? `${v.toString()}n` : v, 2)}`);
}
function serializeEIP1559Transaction(options) {
  assertTransactionEIP1559(options.transaction);
  const { transaction: { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, r, s, v, yParity } } = options;
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    // To fix when migrating to our own version of TransactionSerializable (the viem type is downgraded from Address to string when importing)
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray({ r, s, v, yParity })
  ];
  return `0x02${toRlp(serializedTransaction).slice(2)}`;
}
function serializeEIP2930Transaction(options) {
  assertTransactionEIP2930(options.transaction);
  const { transaction: { chainId, gas, gasPrice, nonce, to, value, accessList, data, r, s, v, yParity } } = options;
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray({ r, s, v, yParity })
  ];
  return `0x01${toRlp(serializedTransaction).slice(2)}`;
}
function serializeTransactionLegacy(options) {
  assertTransactionLegacy(options.transaction);
  const { chainId = 0, gas, data, nonce, to, value, gasPrice, r, s, v } = options.transaction;
  let serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x"
  ];
  if (typeof v !== "undefined") {
    const v_ = (() => {
      if (v >= 35n) {
        const inferredChainId = (v - 35n) / 2n;
        if (inferredChainId > 0)
          return v;
        return 27n + (v === 35n ? 0n : 1n);
      }
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + v - 27n);
      const v_2 = 27n + (v === 27n ? 0n : 1n);
      if (v !== v_2)
        throw new Error(`Invalid legacy signature value v: ${v}`);
      return v_2;
    })();
    if (typeof r === "undefined")
      throw new Error(`Invalid legacy signature value r: ${r}`);
    if (typeof s === "undefined")
      throw new Error(`Invalid legacy signature value s: ${s}`);
    serializedTransaction = [
      ...serializedTransaction,
      toHex(v_),
      r === "0x00" ? "0x" : r,
      s === "0x00" ? "0x" : s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(signature) {
  const { v, yParity } = signature;
  if (typeof signature.r === "undefined")
    return [];
  if (typeof signature.s === "undefined")
    return [];
  if (typeof v === "undefined" && typeof yParity === "undefined")
    return [];
  const r = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (yParity === 1 || yParity === 0)
      return yParity ? toHex(1) : "0x";
    if (typeof yParity !== "undefined")
      throw new Error(`Invalid signature value for yParity: ${yParity}`);
    if (v === 0n || v === 27n)
      return "0x";
    if (v === 1n || v === 28n)
      return toHex(1);
    throw new Error(`Invalid signature value v: ${v}`);
  })();
  return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign.js
function sign({ hash, privateKey }) {
  const { r, s, recovery } = secp256k1.sign(hash.slice(2), privateKey.slice(2));
  return {
    r: toHex(r, { size: 32 }),
    s: toHex(s, { size: 32 }),
    v: recovery ? 28n : 27n,
    yParity: recovery
  };
}

// node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
function signTransaction({ transaction, privateKey }) {
  if (transaction.type === "eip4844") {
    transaction = { ...transaction, sidecars: false };
  }
  const serializedTransaction = serializeTransaction2({ transaction });
  const signature = sign({
    hash: keccak256(serializedTransaction),
    privateKey
  });
  return serializeTransaction2({
    transaction: { ...transaction, ...signature }
  });
}

export {
  sign,
  trim,
  serializeTransaction2 as serializeTransaction,
  signTransaction
};
//# sourceMappingURL=chunk-Z3BOV34S.js.map
