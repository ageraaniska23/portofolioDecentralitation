import {
  getBytecode
} from "./chunk-FPO5TL63.js";
import {
  readContract
} from "./chunk-BF6IWIHR.js";
import {
  getRpcClient
} from "./chunk-KFTJWVLQ.js";
import {
  isAddress
} from "./chunk-UV67MG5D.js";
import {
  toFunctionSelector
} from "./chunk-IAQW7B5J.js";

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getStorageAt.js
async function eth_getStorageAt(request, params) {
  return await request({
    method: "eth_getStorageAt",
    params: [params.address, params.position, params.blockTag ?? "latest"]
  });
}

// node_modules/thirdweb/dist/esm/utils/bytecode/extractMnimalProxyImplementationAddress.js
function extractMinimalProxyImplementationAddress(bytecode) {
  if (!bytecode.startsWith("0x")) {
    bytecode = `0x${bytecode}`;
  }
  if (bytecode.startsWith("0x363d3d373d3d3d363d73")) {
    const implementationAddress = bytecode.slice(22, 62);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x36603057343d5230")) {
    const implementationAddress = bytecode.slice(122, 122 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x3d3d3d3d363d3d37363d73")) {
    const implementationAddress = bytecode.slice(24, 24 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x366000600037611000600036600073")) {
    const implementationAddress = bytecode.slice(32, 32 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x36600080376020600036600073")) {
    const implementationAddress = bytecode.slice(28, 28 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x365f5f375f5f365f73")) {
    const implementationAddress = bytecode.slice(20, 60);
    return `0x${implementationAddress}`;
  }
  return void 0;
}

// node_modules/thirdweb/dist/esm/utils/bytecode/resolveImplementation.js
var AddressZero = "0x0000000000000000000000000000000000000000";
async function resolveImplementation(contract) {
  const [originalBytecode, beacon] = await Promise.all([
    getBytecode(contract),
    getBeaconFromStorageSlot(contract)
  ]);
  const minimalProxyImplementationAddress = extractMinimalProxyImplementationAddress(originalBytecode);
  if (minimalProxyImplementationAddress) {
    return {
      address: minimalProxyImplementationAddress,
      bytecode: await getBytecode({
        ...contract,
        address: minimalProxyImplementationAddress
      })
    };
  }
  let implementationAddress;
  if (beacon && beacon !== AddressZero) {
    contract = { ...contract, address: beacon };
    implementationAddress = await getImplementationFromContractCall(contract);
  } else {
    implementationAddress = await getImplementationFromStorageSlot(contract);
  }
  if (implementationAddress && isAddress(implementationAddress) && implementationAddress !== AddressZero) {
    const implementationBytecode = await getBytecode({
      ...contract,
      address: implementationAddress
    });
    if (implementationBytecode === "0x") {
      return {
        address: contract.address,
        bytecode: originalBytecode
      };
    }
    return {
      address: implementationAddress,
      bytecode: implementationBytecode
    };
  }
  return { address: contract.address, bytecode: originalBytecode };
}
async function getBeaconFromStorageSlot(contract) {
  const rpcRequest = getRpcClient({
    client: contract.client,
    chain: contract.chain
  });
  try {
    const proxyStorage = await eth_getStorageAt(rpcRequest, {
      address: contract.address,
      position: "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50"
    });
    return `0x${proxyStorage.slice(-40)}`;
  } catch {
    return void 0;
  }
}
async function getImplementationFromStorageSlot(contract) {
  const rpcRequest = getRpcClient({
    client: contract.client,
    chain: contract.chain
  });
  try {
    const proxyStorage = await eth_getStorageAt(rpcRequest, {
      address: contract.address,
      position: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
    });
    return `0x${proxyStorage.slice(-40)}`;
  } catch {
    return void 0;
  }
}
var UPGRADEABLE_PROXY_ABI = {
  type: "function",
  name: "implementation",
  inputs: [],
  outputs: [
    {
      type: "address",
      name: "",
      internalType: "address"
    }
  ],
  stateMutability: "view"
};
async function getImplementationFromContractCall(contract) {
  try {
    return await readContract({ contract, method: UPGRADEABLE_PROXY_ABI });
  } catch {
    return void 0;
  }
}

// node_modules/thirdweb/dist/esm/utils/bytecode/detectExtension.js
async function detectMethod(options) {
  const { bytecode } = await resolveImplementation(options.contract);
  return detectMethodInBytecode({ bytecode, method: options.method });
}
function detectMethodInBytecode(options) {
  if (options.bytecode === "0x") {
    return false;
  }
  const fnSelector = Array.isArray(options.method) ? options.method[0] : toFunctionSelector(options.method);
  return options.bytecode.indexOf(fnSelector.slice(2)) > -1;
}

export {
  eth_getStorageAt,
  detectMethod
};
//# sourceMappingURL=chunk-SY6M73X4.js.map
