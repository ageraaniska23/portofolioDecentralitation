{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc1155/__generated__/DropSinglePhase1155/read/claimCondition.ts", "../../thirdweb/src/extensions/erc1155/__generated__/IDrop1155/read/getActiveClaimConditionId.ts", "../../thirdweb/src/extensions/erc1155/__generated__/IDrop1155/read/getClaimConditionById.ts", "../../thirdweb/src/extensions/erc1155/drops/read/getActiveClaimCondition.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"claimCondition\" function.\n */\nexport type ClaimConditionParams = {\n  tokenId: AbiParameterToPrimitiveType<{\n    name: \"_tokenId\";\n    type: \"uint256\";\n    internalType: \"uint256\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xe9703d25\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"_tokenId\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"startTimestamp\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"maxClaimableSupply\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"supplyClaimed\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"quantityLimitPerWallet\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"merkleRoot\",\n    type: \"bytes32\",\n    internalType: \"bytes32\",\n  },\n  {\n    name: \"pricePerToken\",\n    type: \"uint256\",\n    internalType: \"uint256\",\n  },\n  {\n    name: \"currency\",\n    type: \"address\",\n    internalType: \"address\",\n  },\n  {\n    name: \"metadata\",\n    type: \"string\",\n    internalType: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `claimCondition` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `claimCondition` method is supported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isClaimConditionSupported } from \"thirdweb/extensions/erc1155\";\n *\n * const supported = await isClaimConditionSupported(contract);\n * ```\n */\nexport async function isClaimConditionSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"claimCondition\" function.\n * @param options - The options for the claimCondition function.\n * @returns The encoded ABI parameters.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeClaimConditionParams } \"thirdweb/extensions/erc1155\";\n * const result = encodeClaimConditionParams({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeClaimConditionParams(options: ClaimConditionParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId]);\n}\n\n/**\n * Encodes the \"claimCondition\" function into a Hex string with its parameters.\n * @param options - The options for the claimCondition function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeClaimCondition } \"thirdweb/extensions/erc1155\";\n * const result = encodeClaimCondition({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeClaimCondition(options: ClaimConditionParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeClaimConditionParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the claimCondition function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1155\n * @example\n * ```ts\n * import { decodeClaimConditionResult } from \"thirdweb/extensions/erc1155\";\n * const result = decodeClaimConditionResult(\"...\");\n * ```\n */\nexport function decodeClaimConditionResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"claimCondition\" function on the contract.\n * @param options - The options for the claimCondition function.\n * @returns The parsed result of the function call.\n * @extension ERC1155\n * @example\n * ```ts\n * import { claimCondition } from \"thirdweb/extensions/erc1155\";\n *\n * const result = await claimCondition({\n *  contract,\n *  tokenId: ...,\n * });\n *\n * ```\n */\nexport async function claimCondition(\n  options: BaseTransactionOptions<ClaimConditionParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.tokenId],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getActiveClaimConditionId\" function.\n */\nexport type GetActiveClaimConditionIdParams = {\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"_tokenId\" }>;\n};\n\nexport const FN_SELECTOR = \"0x5ab063e8\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"_tokenId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `getActiveClaimConditionId` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `getActiveClaimConditionId` method is supported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isGetActiveClaimConditionIdSupported } from \"thirdweb/extensions/erc1155\";\n *\n * const supported = await isGetActiveClaimConditionIdSupported(contract);\n * ```\n */\nexport async function isGetActiveClaimConditionIdSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getActiveClaimConditionId\" function.\n * @param options - The options for the getActiveClaimConditionId function.\n * @returns The encoded ABI parameters.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeGetActiveClaimConditionIdParams } \"thirdweb/extensions/erc1155\";\n * const result = encodeGetActiveClaimConditionIdParams({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeGetActiveClaimConditionIdParams(\n  options: GetActiveClaimConditionIdParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId]);\n}\n\n/**\n * Encodes the \"getActiveClaimConditionId\" function into a Hex string with its parameters.\n * @param options - The options for the getActiveClaimConditionId function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeGetActiveClaimConditionId } \"thirdweb/extensions/erc1155\";\n * const result = encodeGetActiveClaimConditionId({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeGetActiveClaimConditionId(\n  options: GetActiveClaimConditionIdParams,\n) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetActiveClaimConditionIdParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getActiveClaimConditionId function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1155\n * @example\n * ```ts\n * import { decodeGetActiveClaimConditionIdResult } from \"thirdweb/extensions/erc1155\";\n * const result = decodeGetActiveClaimConditionIdResult(\"...\");\n * ```\n */\nexport function decodeGetActiveClaimConditionIdResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getActiveClaimConditionId\" function on the contract.\n * @param options - The options for the getActiveClaimConditionId function.\n * @returns The parsed result of the function call.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getActiveClaimConditionId } from \"thirdweb/extensions/erc1155\";\n *\n * const result = await getActiveClaimConditionId({\n *  contract,\n *  tokenId: ...,\n * });\n *\n * ```\n */\nexport async function getActiveClaimConditionId(\n  options: BaseTransactionOptions<GetActiveClaimConditionIdParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.tokenId],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getClaimConditionById\" function.\n */\nexport type GetClaimConditionByIdParams = {\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"_tokenId\" }>;\n  conditionId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"_conditionId\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xd45b28d7\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"_tokenId\",\n  },\n  {\n    type: \"uint256\",\n    name: \"_conditionId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"tuple\",\n    name: \"condition\",\n    components: [\n      {\n        type: \"uint256\",\n        name: \"startTimestamp\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxClaimableSupply\",\n      },\n      {\n        type: \"uint256\",\n        name: \"supplyClaimed\",\n      },\n      {\n        type: \"uint256\",\n        name: \"quantityLimitPerWallet\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"merkleRoot\",\n      },\n      {\n        type: \"uint256\",\n        name: \"pricePerToken\",\n      },\n      {\n        type: \"address\",\n        name: \"currency\",\n      },\n      {\n        type: \"string\",\n        name: \"metadata\",\n      },\n    ],\n  },\n] as const;\n\n/**\n * Checks if the `getClaimConditionById` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `getClaimConditionById` method is supported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isGetClaimConditionByIdSupported } from \"thirdweb/extensions/erc1155\";\n *\n * const supported = await isGetClaimConditionByIdSupported(contract);\n * ```\n */\nexport async function isGetClaimConditionByIdSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getClaimConditionById\" function.\n * @param options - The options for the getClaimConditionById function.\n * @returns The encoded ABI parameters.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeGetClaimConditionByIdParams } \"thirdweb/extensions/erc1155\";\n * const result = encodeGetClaimConditionByIdParams({\n *  tokenId: ...,\n *  conditionId: ...,\n * });\n * ```\n */\nexport function encodeGetClaimConditionByIdParams(\n  options: GetClaimConditionByIdParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId, options.conditionId]);\n}\n\n/**\n * Encodes the \"getClaimConditionById\" function into a Hex string with its parameters.\n * @param options - The options for the getClaimConditionById function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeGetClaimConditionById } \"thirdweb/extensions/erc1155\";\n * const result = encodeGetClaimConditionById({\n *  tokenId: ...,\n *  conditionId: ...,\n * });\n * ```\n */\nexport function encodeGetClaimConditionById(\n  options: GetClaimConditionByIdParams,\n) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetClaimConditionByIdParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getClaimConditionById function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1155\n * @example\n * ```ts\n * import { decodeGetClaimConditionByIdResult } from \"thirdweb/extensions/erc1155\";\n * const result = decodeGetClaimConditionByIdResult(\"...\");\n * ```\n */\nexport function decodeGetClaimConditionByIdResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getClaimConditionById\" function on the contract.\n * @param options - The options for the getClaimConditionById function.\n * @returns The parsed result of the function call.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getClaimConditionById } from \"thirdweb/extensions/erc1155\";\n *\n * const result = await getClaimConditionById({\n *  contract,\n *  tokenId: ...,\n *  conditionId: ...,\n * });\n *\n * ```\n */\nexport async function getClaimConditionById(\n  options: BaseTransactionOptions<GetClaimConditionByIdParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.tokenId, options.conditionId],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport type { ClaimCondition } from \"../../../../utils/extensions/drops/types.js\";\nimport { claimCondition } from \"../../__generated__/DropSinglePhase1155/read/claimCondition.js\";\nimport {\n  type GetActiveClaimConditionIdParams,\n  getActiveClaimConditionId,\n} from \"../../__generated__/IDrop1155/read/getActiveClaimConditionId.js\";\nimport { getClaimConditionById } from \"../../__generated__/IDrop1155/read/getClaimConditionById.js\";\n\nexport type GetActiveClaimConditionParams = GetActiveClaimConditionIdParams;\n/**\n * Retrieves the active claim condition.\n * @param options - The transaction options.\n * @returns A promise that resolves to the active claim condition.\n * @throws An error if the claim condition is unsupported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getActiveClaimCondition } from \"thirdweb/extensions/erc1155\";\n * const activeClaimCondition = await getActiveClaimCondition({ contract, tokenId });\n * ```\n */\nexport async function getActiveClaimCondition(\n  options: BaseTransactionOptions<GetActiveClaimConditionParams>,\n): Promise<ClaimCondition> {\n  const getActiveClaimConditionMultiPhase = async () => {\n    const conditionId = await getActiveClaimConditionId(options);\n    return getClaimConditionById({ ...options, conditionId });\n  };\n  const getActiveClaimConditionSinglePhase = async () => {\n    const [\n      startTimestamp,\n      maxClaimableSupply,\n      supplyClaimed,\n      quantityLimitPerWallet,\n      merkleRoot,\n      pricePerToken,\n      currency,\n      metadata,\n    ] = await claimCondition({ ...options, tokenId: options.tokenId });\n    return {\n      startTimestamp,\n      maxClaimableSupply,\n      supplyClaimed,\n      quantityLimitPerWallet,\n      merkleRoot,\n      pricePerToken,\n      currency,\n      metadata,\n    };\n  };\n\n  // The contract's phase type is unknown, so try both options and return whichever resolves, prioritizing multi-phase\n  const results = await Promise.allSettled([\n    getActiveClaimConditionMultiPhase(),\n    getActiveClaimConditionSinglePhase(),\n  ]);\n\n  const condition = results.find((result) => result.status === \"fulfilled\");\n  if (condition?.status === \"fulfilled\") {\n    return condition.value;\n  }\n  throw new Error(\"Claim condition not found\");\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBO,IAAM,cAAc;AAC3B,IAAM,YAAY;EAChB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;;AAGlB,IAAM,aAAa;EACjB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;EAEhB;IACE,MAAM;IACN,MAAM;IACN,cAAc;;;AA+FlB,eAAsB,eACpB,SAAqD;AAErD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAAC,aAAa,WAAW,UAAU;IAC3C,QAAQ,CAAC,QAAQ,OAAO;GACzB;AACH;;;AC1JO,IAAMA,eAAc;AAC3B,IAAMC,aAAY;EAChB;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,cAAa;EACjB;IACE,MAAM;;;AAmGV,eAAsB,0BACpB,SAAgE;AAEhE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAC,QAAQ,OAAO;GACzB;AACH;;;AChHO,IAAMC,eAAc;AAC3B,IAAMC,aAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,cAAa;EACjB;IACE,MAAM;IACN,MAAM;IACN,YAAY;MACV;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;;;;AAwGd,eAAsB,sBACpB,SAA4D;AAE5D,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAC,QAAQ,SAAS,QAAQ,WAAW;GAC9C;AACH;;;AC5JA,eAAsB,wBACpB,SAA8D;AAE9D,QAAM,oCAAoC,YAAW;AACnD,UAAM,cAAc,MAAM,0BAA0B,OAAO;AAC3D,WAAO,sBAAsB,EAAE,GAAG,SAAS,YAAW,CAAE;EAC1D;AACA,QAAM,qCAAqC,YAAW;AACpD,UAAM,CACJ,gBACA,oBACA,eACA,wBACA,YACA,eACA,UACA,QAAQ,IACN,MAAM,eAAe,EAAE,GAAG,SAAS,SAAS,QAAQ,QAAO,CAAE;AACjE,WAAO;MACL;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;EAEJ;AAGA,QAAM,UAAU,MAAM,QAAQ,WAAW;IACvC,kCAAiC;IACjC,mCAAkC;GACnC;AAED,QAAM,YAAY,QAAQ,KAAK,CAAC,WAAW,OAAO,WAAW,WAAW;AACxE,OAAI,uCAAW,YAAW,aAAa;AACrC,WAAO,UAAU;EACnB;AACA,QAAM,IAAI,MAAM,2BAA2B;AAC7C;",
  "names": ["FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS"]
}
