import {
  Img,
  appleIconUri,
  discordIconUri,
  emailIcon,
  facebookIconUri,
  farcasterIconUri,
  genericWalletIcon,
  getLastAuthProvider,
  googleIconUri,
  passkeyIcon,
  phoneIcon,
  radius,
  telegramIconUri,
  useConnectionManagerCtx,
  useQuery
} from "./chunk-WOF5MGUW.js";
import {
  deleteConnectParamsFromStorage
} from "./chunk-RMLEFI72.js";
import {
  getWalletBalance
} from "./chunk-E2DOQKS2.js";
import {
  webLocalStorage
} from "./chunk-57DFWRZ3.js";
import {
  getWalletInfo
} from "./chunk-3MCYWU5O.js";
import {
  getInstalledWalletProviders
} from "./chunk-X54FPRZI.js";
import {
  smartWallet
} from "./chunk-7XC4GPHZ.js";
import {
  createStore
} from "./chunk-OSZAYZBM.js";
import {
  resolveScheme
} from "./chunk-PZWOPBWI.js";
import {
  getContract
} from "./chunk-V4R6W4TB.js";
import {
  readContract
} from "./chunk-BF6IWIHR.js";
import {
  labelhash
} from "./chunk-4OMQ45VH.js";
import {
  encodeAbiParameters
} from "./chunk-3UYCMIWJ.js";
import {
  isAddress
} from "./chunk-UV67MG5D.js";
import {
  keccak256,
  stringToBytes,
  toBytes
} from "./chunk-CY3CMUVN.js";
import {
  isHex,
  toHex
} from "./chunk-BNK74YTA.js";
import {
  bytesToHex,
  concat,
  decodeAbiParameters
} from "./chunk-IAQW7B5J.js";
import {
  ethereum
} from "./chunk-TT4DF327.js";
import {
  getCachedChain,
  withCache
} from "./chunk-SYYDPSNZ.js";
import {
  getClientFetch
} from "./chunk-SUMWJFR6.js";
import {
  require_jsx_runtime
} from "./chunk-6PF5PHNV.js";
import {
  require_react
} from "./chunk-7SNDHR3H.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/thirdweb/dist/esm/react/core/hooks/wallets/useActiveWallet.js
var import_react = __toESM(require_react(), 1);
function useActiveWallet() {
  const manager = useConnectionManagerCtx("useActiveWallet");
  const store = manager.activeWalletStore;
  return (0, import_react.useSyncExternalStore)(store.subscribe, store.getValue, store.getValue);
}

// node_modules/thirdweb/dist/esm/react/core/hooks/others/useWalletBalance.js
function useWalletBalance(options, queryOptions) {
  const { chain, address, tokenAddress, client } = options;
  return useQuery({
    ...queryOptions,
    queryKey: [
      "walletBalance",
      (chain == null ? void 0 : chain.id) || -1,
      address || "0x0",
      { tokenAddress }
    ],
    queryFn: async () => {
      if (!chain) {
        throw new Error("chain is required");
      }
      if (!client) {
        throw new Error("client is required");
      }
      if (!address) {
        throw new Error("address is required");
      }
      return getWalletBalance({
        chain,
        client,
        address,
        tokenAddress
      });
    },
    enabled: !!chain && !!client && !!address
  });
}

// node_modules/thirdweb/dist/esm/utils/ens/avatar.js
async function parseAvatarRecord(options) {
  let uri = options.uri;
  if (/eip155:/i.test(options.uri)) {
    uri = await parseNftUri(options);
  }
  if (!uri) {
    return null;
  }
  const resolvedScheme = resolveScheme({
    client: options.client,
    uri
  });
  if (await isImageUri({ client: options.client, uri: resolvedScheme })) {
    return resolvedScheme;
  }
  return null;
}
async function parseNftUri(options) {
  let uri = options.uri;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference = "", asset_namespace = "", tokenID = ""] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155") {
    throw new Error(`Invalid EIP namespace, expected EIP155, got: "${eip_namespace}"`);
  }
  if (!chainID) {
    throw new Error("Chain ID not found");
  }
  if (!contractAddress || !isAddress(contractAddress)) {
    throw new Error("Contract address not found");
  }
  if (!tokenID) {
    throw new Error("Token ID not found");
  }
  const chain = getCachedChain(Number(chainID));
  const contract = getContract({
    client: options.client,
    chain,
    address: contractAddress
  });
  switch (erc_namespace) {
    case "erc721": {
      const { getNFT } = await import("./getNFT-F4AVWZU3.js");
      const nft = await getNFT({
        contract,
        tokenId: BigInt(tokenID)
      });
      return nft.metadata.image ?? null;
    }
    case "erc1155": {
      const { getNFT } = await import("./getNFT-2PE3GPEU.js");
      const nft = await getNFT({
        contract,
        tokenId: BigInt(tokenID)
      });
      return nft.metadata.image ?? null;
    }
    default: {
      throw new Error(`Invalid ERC namespace, expected ERC721 or ERC1155, got: "${erc_namespace}"`);
    }
  }
}
async function isImageUri(options) {
  try {
    const res = await getClientFetch(options.client)(options.uri, {
      method: "HEAD"
    });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return !!(contentType == null ? void 0 : contentType.startsWith("image/"));
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (Object.hasOwn(globalThis, "Image")) {
      return false;
    }
    return new Promise((resolve2) => {
      const img = new Image();
      img.onload = () => {
        resolve2(true);
      };
      img.onerror = () => {
        resolve2(false);
      };
      img.src = options.uri;
    });
  }
}

// node_modules/thirdweb/dist/esm/utils/ens/encodeLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66) {
    return null;
  }
  if (label.indexOf("[") !== 0) {
    return null;
  }
  if (label.indexOf("]") !== 65) {
    return null;
  }
  const hash = `0x${label.slice(1, 65)}`;
  if (!isHex(hash)) {
    return null;
  }
  return hash;
}

// node_modules/thirdweb/dist/esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name) {
    return bytesToHex(result);
  }
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const item = labels[i];
    const hashFromEncodedLabel = encodedLabelToLabelhash(item);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(item), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// node_modules/thirdweb/dist/esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash) {
  return `[${hash.slice(2)}]`;
}

// node_modules/thirdweb/dist/esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0) {
    return new Uint8Array(1);
  }
  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    let encoded = stringToBytes(item);
    if (encoded.byteLength > 255) {
      encoded = stringToBytes(encodeLabelhash(labelhash(item)));
    }
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes.byteLength !== offset + 1) {
    return bytes.slice(0, offset + 1);
  }
  return bytes;
}

// node_modules/thirdweb/dist/esm/extensions/ens/__generated__/AddressResolver/read/text.js
var FN_SELECTOR = "0x59d1d43c";
var FN_INPUTS = [
  {
    type: "bytes32",
    name: "name"
  },
  {
    type: "string",
    name: "key"
  }
];
var FN_OUTPUTS = [
  {
    type: "string"
  }
];
function encodeTextParams(options) {
  return encodeAbiParameters(FN_INPUTS, [options.name, options.key]);
}
function encodeText(options) {
  return FN_SELECTOR + encodeTextParams(options).slice(2);
}
function decodeTextResult(result) {
  return decodeAbiParameters(FN_OUTPUTS, result)[0];
}

// node_modules/thirdweb/dist/esm/extensions/ens/__generated__/UniversalResolver/read/resolve.js
var FN_SELECTOR2 = "0x9061b923";
var FN_INPUTS2 = [
  {
    type: "bytes",
    name: "name"
  },
  {
    type: "bytes",
    name: "data"
  }
];
var FN_OUTPUTS2 = [
  {
    type: "bytes"
  },
  {
    type: "address"
  }
];
async function resolve(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2],
    params: [options.name, options.data]
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/constants.js
var UNIVERSAL_RESOLVER_ADDRESS = "0xce01f8eee7E479C928F8919abD53E553a36CeF67";

// node_modules/thirdweb/dist/esm/extensions/ens/resolve-text.js
async function resolveText(options) {
  const { client, name, key, resolverAddress, resolverChain } = options;
  return withCache(async () => {
    const contract = getContract({
      client,
      chain: resolverChain || ethereum,
      address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS
    });
    const data = encodeText({ name: namehash(name), key });
    const result = await resolve({
      contract,
      name: toHex(packetToBytes(name)),
      data
    });
    if (result[0] === "0x") {
      return null;
    }
    const record = decodeTextResult(result[0]);
    return record === "" ? null : record;
  }, {
    cacheKey: `ens:text:${name}:${key}`,
    // 1min cache
    cacheTime: 60 * 1e3
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/resolve-avatar.js
async function resolveAvatar(options) {
  const { client, name, resolverAddress, resolverChain } = options;
  return withCache(async () => {
    const record = await resolveText({
      client,
      key: "avatar",
      name,
      resolverAddress,
      resolverChain
    });
    if (!record) {
      return null;
    }
    try {
      return parseAvatarRecord({ uri: record, client });
    } catch (e) {
      console.error("Error parsing avatar record", e);
      return null;
    }
  }, {
    cacheKey: `ens:avatar:${name}`,
    // 1min cache
    cacheTime: 60 * 1e3
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/__generated__/UniversalResolver/read/reverse.js
var FN_SELECTOR3 = "0xec11c823";
var FN_INPUTS3 = [
  {
    type: "bytes",
    name: "reverseName"
  }
];
var FN_OUTPUTS3 = [
  {
    type: "string"
  },
  {
    type: "address"
  },
  {
    type: "address"
  },
  {
    type: "address"
  }
];
async function reverse(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR3, FN_INPUTS3, FN_OUTPUTS3],
    params: [options.reverseName]
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/resolve-name.js
async function resolveName(options) {
  const { client, address, resolverAddress, resolverChain } = options;
  return withCache(async () => {
    const contract = getContract({
      client,
      chain: resolverChain || ethereum,
      address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS
    });
    const reverseName = toHex(packetToBytes(`${address.toLowerCase().substring(2)}.addr.reverse`));
    const [name, resolvedAddress] = await reverse({
      contract,
      reverseName
    }).catch((e) => {
      if ("data" in e && e.data === "0x7199966d") {
        return [null, address];
      }
      throw e;
    });
    if (address.toLowerCase() !== resolvedAddress.toLowerCase()) {
      return null;
    }
    return name;
  }, {
    cacheKey: `ens:name:${address}`,
    // 1min cache
    cacheTime: 60 * 1e3
  });
}

// node_modules/thirdweb/dist/esm/react/core/utils/addresses.js
function shortenString(str, extraShort = true) {
  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(str.length - (extraShort ? 3 : 4))}`;
}

// node_modules/thirdweb/dist/esm/react/core/utils/wallet.js
function useEnsName(options) {
  const { client, address } = options;
  return useQuery({
    queryKey: ["ens-name", address],
    enabled: !!address,
    queryFn: () => resolveName({
      client,
      address: address || "",
      resolverChain: ethereum
    })
  });
}
function useEnsAvatar(options) {
  const { client, ensName } = options;
  return useQuery({
    queryKey: ["ens-avatar", ensName],
    enabled: !!ensName,
    queryFn: async () => resolveAvatar({
      client,
      name: ensName || ""
    })
  });
}
function useConnectedWalletDetails(client, walletChain, activeAccount, displayBalanceToken) {
  const tokenAddress = walletChain && displayBalanceToken ? displayBalanceToken[Number(walletChain.id)] : void 0;
  const ensNameQuery = useEnsName({
    client,
    address: activeAccount == null ? void 0 : activeAccount.address
  });
  const ensAvatarQuery = useEnsAvatar({
    client,
    ensName: ensNameQuery.data
  });
  const shortAddress = (activeAccount == null ? void 0 : activeAccount.address) ? shortenString(activeAccount.address, false) : "";
  const balanceQuery = useWalletBalance({
    chain: walletChain ? walletChain : void 0,
    tokenAddress,
    address: activeAccount == null ? void 0 : activeAccount.address,
    client
  });
  const addressOrENS = ensNameQuery.data || shortAddress;
  return {
    ensNameQuery,
    ensAvatarQuery,
    addressOrENS,
    shortAddress,
    balanceQuery
  };
}
function useWalletInfo(id) {
  return useQuery({
    queryKey: ["wallet-info", id],
    queryFn: () => {
      if (!id) {
        throw new Error("Wallet id is required");
      }
      return getWalletInfo(id, false);
    },
    retry: false,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    enabled: !!id
  });
}
function useWalletImage(id) {
  return useQuery({
    queryKey: ["wallet-image", id],
    queryFn: () => {
      if (!id) {
        throw new Error("Wallet id is required");
      }
      return getWalletInfo(id, true);
    },
    retry: false,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    enabled: !!id
  });
}
function hasSponsoredTransactionsEnabled(wallet) {
  if (!wallet) {
    return false;
  }
  let sponsoredTransactionsEnabled = false;
  if (wallet && wallet.id === "smart") {
    const options = wallet.getConfig();
    if ("sponsorGas" in options) {
      sponsoredTransactionsEnabled = options.sponsorGas;
    }
    if ("gasless" in options) {
      sponsoredTransactionsEnabled = options.gasless;
    }
  }
  if (wallet && wallet.id === "inApp") {
    const options = wallet.getConfig();
    if (options && "smartAccount" in options && options.smartAccount) {
      const smartOptions = options.smartAccount;
      if ("sponsorGas" in smartOptions) {
        sponsoredTransactionsEnabled = smartOptions.sponsorGas;
      }
      if ("gasless" in smartOptions) {
        sponsoredTransactionsEnabled = smartOptions.gasless;
      }
    }
  }
  return sponsoredTransactionsEnabled;
}

// node_modules/thirdweb/dist/esm/react/core/utils/isSmartWallet.js
function hasSmartAccount(activeWallet) {
  const config = activeWallet == null ? void 0 : activeWallet.getConfig();
  return !!activeWallet && (activeWallet.id === "smart" || activeWallet.id === "inApp" && !!config && "smartAccount" in config);
}

// node_modules/thirdweb/dist/esm/reactive/computedStore.js
function computedStore(computation, dependencies) {
  const listeners = /* @__PURE__ */ new Set();
  let value = computation();
  const notify = () => {
    for (const listener of listeners) {
      listener();
    }
  };
  const setValue = (newValue) => {
    value = newValue;
    notify();
  };
  for (const store of dependencies) {
    store.subscribe(() => {
      setValue(computation());
    });
  }
  return {
    getValue() {
      return value;
    },
    subscribe(listener) {
      listeners.add(listener);
      return () => {
        listeners.delete(listener);
      };
    }
  };
}

// node_modules/thirdweb/dist/esm/reactive/effect.js
function effect(effectFn, dependencies, runOnMount = true) {
  if (runOnMount) {
    effectFn();
  }
  const unsubscribeList = dependencies.map((store) => {
    return store.subscribe(() => {
      effectFn();
    });
  });
  return () => {
    for (const fn of unsubscribeList) {
      fn();
    }
  };
}

// node_modules/thirdweb/dist/esm/wallets/manager/index.js
var CONNECTED_WALLET_IDS = "thirdweb:connected-wallet-ids";
var LAST_ACTIVE_EOA_ID = "thirdweb:active-wallet-id";
var LAST_ACTIVE_CHAIN = "thirdweb:active-chain";
function createConnectionManager(storage) {
  const activeWalletStore = createStore(void 0);
  const activeAccountStore = createStore(void 0);
  const activeWalletChainStore = createStore(void 0);
  const activeWalletConnectionStatusStore = createStore("disconnected");
  const walletIdToConnectedWalletMap = createStore(/* @__PURE__ */ new Map());
  const isAutoConnecting = createStore(false);
  const connectedWallets = computedStore(() => {
    return Array.from(walletIdToConnectedWalletMap.getValue().values());
  }, [walletIdToConnectedWalletMap]);
  const addConnectedWallet = (wallet) => {
    const oldValue = walletIdToConnectedWalletMap.getValue();
    if (oldValue.has(wallet.id)) {
      return;
    }
    const newValue = new Map(oldValue);
    newValue.set(wallet.id, wallet);
    walletIdToConnectedWalletMap.setValue(newValue);
  };
  const removeConnectedWallet = (wallet) => {
    const oldValue = walletIdToConnectedWalletMap.getValue();
    const newValue = new Map(oldValue);
    newValue.delete(wallet.id);
    walletIdToConnectedWalletMap.setValue(newValue);
  };
  const onWalletDisconnect = (wallet) => {
    deleteConnectParamsFromStorage(storage, wallet.id);
    removeConnectedWallet(wallet);
    if (activeWalletStore.getValue() === wallet) {
      storage.removeItem(LAST_ACTIVE_EOA_ID);
      activeAccountStore.setValue(void 0);
      activeWalletChainStore.setValue(void 0);
      activeWalletStore.setValue(void 0);
      activeWalletConnectionStatusStore.setValue("disconnected");
    }
  };
  const disconnectWallet = (wallet) => {
    onWalletDisconnect(wallet);
    wallet.disconnect();
  };
  const handleConnection = async (wallet, options) => {
    const account = wallet.getAccount();
    if (!account) {
      throw new Error("Can not set a wallet without an account as active");
    }
    const personalWallet = wallet;
    let activeWallet = personalWallet;
    const isInAppSmartAccount = hasSmartAccount(wallet);
    if ((options == null ? void 0 : options.accountAbstraction) && !isInAppSmartAccount) {
      activeWallet = smartWallet(options.accountAbstraction);
      await activeWallet.connect({
        personalAccount: wallet.getAccount(),
        client: options.client
      });
    }
    handleSetActiveWallet(activeWallet);
    addConnectedWallet(personalWallet);
    if (personalWallet.id !== "smart") {
      await storage.setItem(LAST_ACTIVE_EOA_ID, personalWallet.id);
    }
    return activeWallet;
  };
  const connect = async (wallet, options) => {
    var _a;
    const connectedWallet = await handleConnection(wallet, options);
    (_a = options == null ? void 0 : options.onConnect) == null ? void 0 : _a.call(options, connectedWallet);
    handleSetActiveWallet(connectedWallet);
    return connectedWallet;
  };
  const handleSetActiveWallet = (activeWallet) => {
    const account = activeWallet.getAccount();
    if (!account) {
      throw new Error("Can not set a wallet without an account as active");
    }
    addConnectedWallet(activeWallet);
    activeWalletStore.setValue(activeWallet);
    activeAccountStore.setValue(account);
    activeWalletChainStore.setValue(activeWallet.getChain());
    activeWalletConnectionStatusStore.setValue("connected");
    const onAccountsChanged = (newAccount) => {
      activeAccountStore.setValue(newAccount);
    };
    const unsubAccounts = activeWallet.subscribe("accountChanged", onAccountsChanged);
    const unsubChainChanged = activeWallet.subscribe("chainChanged", (chain) => activeWalletChainStore.setValue(chain));
    const unsubDisconnect = activeWallet.subscribe("disconnect", () => {
      handleDisconnect();
    });
    const handleDisconnect = () => {
      onWalletDisconnect(activeWallet);
      unsubAccounts();
      unsubChainChanged();
      unsubDisconnect();
    };
  };
  const setActiveWallet = async (activeWallet) => {
    handleSetActiveWallet(activeWallet);
    if (activeWallet.id !== "smart") {
      await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);
    }
  };
  effect(() => {
    const _chain = activeWalletChainStore.getValue();
    if (_chain) {
      storage.setItem(LAST_ACTIVE_CHAIN, JSON.stringify(_chain));
    } else {
      storage.removeItem(LAST_ACTIVE_CHAIN);
    }
  }, [activeWalletChainStore], false);
  effect(() => {
    const accounts = connectedWallets.getValue();
    const ids = accounts.map((acc) => acc == null ? void 0 : acc.id).filter((c) => !!c);
    storage.setItem(CONNECTED_WALLET_IDS, JSON.stringify(ids));
  }, [connectedWallets], false);
  const switchActiveWalletChain = async (chain) => {
    const wallet = activeWalletStore.getValue();
    if (!wallet) {
      throw new Error("no wallet found");
    }
    if (!wallet.switchChain) {
      throw new Error("wallet does not support switching chains");
    }
    if (wallet.id === "smart") {
      const personalWalletId = await getStoredActiveWalletId(storage);
      if (personalWalletId) {
        const personalWallet = connectedWallets.getValue().find((w) => w.id === personalWalletId);
        if (personalWallet) {
          await personalWallet.switchChain(chain);
        }
      }
      await wallet.switchChain(chain);
      handleSetActiveWallet(wallet);
    } else {
      await wallet.switchChain(chain);
    }
    activeWalletChainStore.setValue(wallet.getChain());
  };
  return {
    // account
    activeWalletStore,
    activeAccountStore,
    connectedWallets,
    addConnectedWallet,
    disconnectWallet,
    setActiveWallet,
    connect,
    handleConnection,
    activeWalletChainStore,
    switchActiveWalletChain,
    activeWalletConnectionStatusStore,
    isAutoConnecting,
    removeConnectedWallet
  };
}
async function getStoredConnectedWalletIds(storage) {
  try {
    const value = await storage.getItem(CONNECTED_WALLET_IDS);
    if (value) {
      return JSON.parse(value);
    }
    return [];
  } catch {
    return [];
  }
}
async function getStoredActiveWalletId(storage) {
  try {
    const value = await storage.getItem(LAST_ACTIVE_EOA_ID);
    if (value) {
      return value;
    }
    return null;
  } catch {
    return null;
  }
}
async function getLastConnectedChain(storage) {
  try {
    const value = await storage.getItem(LAST_ACTIVE_CHAIN);
    if (value) {
      return JSON.parse(value);
    }
    return null;
  } catch {
    return null;
  }
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/WalletImage.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
function WalletImage(props) {
  const [image, setImage] = (0, import_react2.useState)(void 0);
  const activeWallet = useActiveWallet();
  (0, import_react2.useEffect)(() => {
    async function fetchImage() {
      var _a;
      const storage = webLocalStorage;
      let activeEOAId = props.id;
      if (props.id === "smart") {
        const storedId = await getStoredActiveWalletId(storage);
        if (storedId) {
          activeEOAId = storedId;
        }
      }
      let image2;
      if (activeEOAId === "inApp" && activeWallet && (activeWallet.id === "inApp" || activeWallet.id === "smart")) {
        const lastAuthProvider = await getLastAuthProvider(storage);
        switch (lastAuthProvider) {
          case "google":
            image2 = googleIconUri;
            break;
          case "apple":
            image2 = appleIconUri;
            break;
          case "facebook":
            image2 = facebookIconUri;
            break;
          case "phone":
            image2 = phoneIcon;
            break;
          case "email":
            image2 = emailIcon;
            break;
          case "passkey":
            image2 = passkeyIcon;
            break;
          case "discord":
            image2 = discordIconUri;
            break;
          case "farcaster":
            image2 = farcasterIconUri;
            break;
          case "telegram":
            image2 = telegramIconUri;
            break;
        }
      } else {
        const mipdImage = (_a = getInstalledWalletProviders().find((x) => x.info.rdns === activeEOAId)) == null ? void 0 : _a.info.icon;
        if (mipdImage) {
          image2 = mipdImage;
        } else {
          image2 = await getWalletInfo(activeEOAId, true);
        }
      }
      setImage(image2);
    }
    fetchImage();
  }, [props.id, activeWallet]);
  if (image) {
    return (0, import_jsx_runtime.jsx)(Img, { src: image, width: props.size, height: props.size, loading: "eager", client: props.client, style: {
      borderRadius: radius.md,
      ...props.style
    } });
  }
  return (0, import_jsx_runtime.jsx)(WalletImageQuery, { id: props.id, size: props.size, client: props.client });
}
function WalletImageQuery(props) {
  const walletImage = useWalletImage(props.id);
  if (walletImage.isFetched && !walletImage.data) {
    return (0, import_jsx_runtime.jsx)(Img, { client: props.client, src: genericWalletIcon, width: props.size, height: props.size });
  }
  return (0, import_jsx_runtime.jsx)(Img, { client: props.client, src: walletImage.isLoading ? void 0 : walletImage.data, fallbackImage: genericWalletIcon, width: props.size, height: props.size, loading: "eager", style: {
    borderRadius: radius.md
  } });
}

export {
  useActiveWallet,
  hasSmartAccount,
  createConnectionManager,
  getStoredConnectedWalletIds,
  getStoredActiveWalletId,
  getLastConnectedChain,
  namehash,
  packetToBytes,
  resolve,
  UNIVERSAL_RESOLVER_ADDRESS,
  useWalletBalance,
  shortenString,
  useEnsName,
  useEnsAvatar,
  useConnectedWalletDetails,
  useWalletInfo,
  useWalletImage,
  hasSponsoredTransactionsEnabled,
  WalletImage
};
//# sourceMappingURL=chunk-JPZW4FOA.js.map
