{
  "version": 3,
  "sources": ["../../thirdweb/src/react/core/hooks/wallets/useActiveWallet.ts", "../../thirdweb/src/react/core/hooks/others/useWalletBalance.ts", "../../thirdweb/src/utils/ens/avatar.ts", "../../thirdweb/src/utils/ens/encodeLabelToLabelhash.ts", "../../thirdweb/src/utils/ens/namehash.ts", "../../thirdweb/src/utils/ens/encodeLabelhash.ts", "../../thirdweb/src/utils/ens/packetToBytes.ts", "../../thirdweb/src/extensions/ens/__generated__/AddressResolver/read/text.ts", "../../thirdweb/src/extensions/ens/__generated__/UniversalResolver/read/resolve.ts", "../../thirdweb/src/extensions/ens/constants.ts", "../../thirdweb/src/extensions/ens/resolve-text.ts", "../../thirdweb/src/extensions/ens/resolve-avatar.ts", "../../thirdweb/src/extensions/ens/__generated__/UniversalResolver/read/reverse.ts", "../../thirdweb/src/extensions/ens/resolve-name.ts", "../../thirdweb/src/react/core/utils/addresses.ts", "../../thirdweb/src/react/core/utils/wallet.ts", "../../thirdweb/src/react/core/utils/isSmartWallet.ts", "../../thirdweb/src/reactive/computedStore.ts", "../../thirdweb/src/reactive/effect.ts", "../../thirdweb/src/wallets/manager/index.ts", "../../thirdweb/src/react/web/ui/components/WalletImage.tsx"],
  "sourcesContent": ["import { useSyncExternalStore } from \"react\";\nimport { useConnectionManagerCtx } from \"../../providers/connection-manager.js\";\n\n/**\n * A hook that returns the active wallet\n * @returns The active `Wallet` or `undefined` if no active wallet is set.\n * @example\n * ```jsx\n * import { useActiveWallet } from \"thirdweb/react\";\n *\n * const wallet = useActiveWallet();\n * ```\n * @walletConnection\n */\nexport function useActiveWallet() {\n  const manager = useConnectionManagerCtx(\"useActiveWallet\");\n  const store = manager.activeWalletStore;\n  return useSyncExternalStore(store.subscribe, store.getValue, store.getValue);\n}\n", "import {\n  type UseQueryOptions,\n  type UseQueryResult,\n  useQuery,\n} from \"@tanstack/react-query\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { Prettify } from \"../../../../utils/type-utils.js\";\nimport {\n  type GetWalletBalanceOptions,\n  type GetWalletBalanceResult,\n  getWalletBalance,\n} from \"../../../../wallets/utils/getWalletBalance.js\";\n\nexport type UseWalletBalanceOptions = Prettify<\n  Omit<GetWalletBalanceOptions, \"address\" | \"chain\"> & {\n    address: string | undefined;\n    chain: Chain | undefined;\n  }\n>;\nexport type UseWalletBalanceQueryOptions = Omit<\n  UseQueryOptions<GetWalletBalanceResult>,\n  \"queryFn\" | \"queryKey\" | \"enabled\"\n>;\n\n/**\n * Fetch the balance of a wallet in native currency or for a specific token.\n * Leave `tokenAddress` undefined to fetch the native token balance.\n * @param options {@link GetWalletBalanceOptions} - The options for fetching the wallet balance.\n * @param options.chain - The chain to fetch the wallet balance from.\n * @param options.address - The address of the wallet to fetch the balance from.\n * @param options.client - The client to use to fetch the wallet balance.\n * @param [options.tokenAddress] - The address of the token to fetch the balance for.\n * @returns {@link GetWalletBalanceResult} The result of the query.\n *\n * @example\n *\n * ### Fetching the native token balance\n *\n * ```ts\n * import { useWalletBalance } from \"thirdweb/react\";\n *\n * const { data, isLoading, isError } = useWalletBalance({ chain, address, client });\n * console.log(\"balance\", data?.displayValue, data?.symbol);\n * ```\n *\n * ### Fetching a specific token balance\n *\n * ```ts\n * import { useWalletBalance } from \"thirdweb/react\";\n *\n * const tokenAddress = \"0x...\"; // the ERC20 token address\n *\n * const { data, isLoading, isError } = useWalletBalance({ chain, address, client, tokenAddress });\n * console.log(\"balance\", data?.displayValue, data?.symbol);\n * ```\n * @wallet\n */\nexport function useWalletBalance(\n  options: UseWalletBalanceOptions,\n  queryOptions?: UseWalletBalanceQueryOptions,\n): UseQueryResult<GetWalletBalanceResult> {\n  const { chain, address, tokenAddress, client } = options;\n  return useQuery({\n    ...queryOptions,\n    queryKey: [\n      \"walletBalance\",\n      chain?.id || -1,\n      address || \"0x0\",\n      { tokenAddress },\n    ] as const,\n    queryFn: async () => {\n      if (!chain) {\n        throw new Error(\"chain is required\");\n      }\n      if (!client) {\n        throw new Error(\"client is required\");\n      }\n      if (!address) {\n        throw new Error(\"address is required\");\n      }\n      return getWalletBalance({\n        chain,\n        client,\n        address,\n        tokenAddress,\n      });\n    },\n    enabled: !!chain && !!client && !!address,\n  });\n}\n", "import { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { isAddress } from \"../address.js\";\nimport { getClientFetch } from \"../fetch.js\";\nimport { resolveScheme } from \"../ipfs.js\";\n\ntype AvatarOptions = {\n  client: ThirdwebClient;\n  uri: string;\n};\n\n/**\n * @internal\n */\nexport async function parseAvatarRecord(\n  options: AvatarOptions,\n): Promise<string | null> {\n  let uri: string | null = options.uri;\n  if (/eip155:/i.test(options.uri)) {\n    // do nft uri parsing\n    uri = await parseNftUri(options);\n  }\n  if (!uri) {\n    return null;\n  }\n  const resolvedScheme = resolveScheme({\n    client: options.client,\n    uri,\n  });\n\n  // check if it's an image\n  if (await isImageUri({ client: options.client, uri: resolvedScheme })) {\n    return resolvedScheme;\n  }\n  return null;\n}\n\n/**\n * @internal\n */\nasync function parseNftUri(options: AvatarOptions): Promise<string | null> {\n  let uri = options.uri;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith(\"did:nft:\")) {\n    // convert DID to CAIP\n    uri = uri.replace(\"did:nft:\", \"\").replace(/_/g, \"/\");\n  }\n\n  const [reference = \"\", asset_namespace = \"\", tokenID = \"\"] = uri.split(\"/\");\n  const [eip_namespace, chainID] = reference.split(\":\");\n  const [erc_namespace, contractAddress] = asset_namespace.split(\":\");\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== \"eip155\") {\n    throw new Error(\n      `Invalid EIP namespace, expected EIP155, got: \"${eip_namespace}\"`,\n    );\n  }\n  if (!chainID) {\n    throw new Error(\"Chain ID not found\");\n  }\n  if (!contractAddress || !isAddress(contractAddress)) {\n    throw new Error(\"Contract address not found\");\n  }\n  if (!tokenID) {\n    throw new Error(\"Token ID not found\");\n  }\n  const chain = getCachedChain(Number(chainID));\n  const contract = getContract({\n    client: options.client,\n    chain,\n    address: contractAddress,\n  });\n  switch (erc_namespace) {\n    case \"erc721\": {\n      const { getNFT } = await import(\"../../extensions/erc721/read/getNFT.js\");\n      const nft = await getNFT({\n        contract,\n        tokenId: BigInt(tokenID),\n      });\n      return nft.metadata.image ?? null;\n    }\n    case \"erc1155\": {\n      const { getNFT } = await import(\n        \"../../extensions/erc1155/read/getNFT.js\"\n      );\n      const nft = await getNFT({\n        contract,\n        tokenId: BigInt(tokenID),\n      });\n      return nft.metadata.image ?? null;\n    }\n\n    default: {\n      throw new Error(\n        `Invalid ERC namespace, expected ERC721 or ERC1155, got: \"${erc_namespace}\"`,\n      );\n    }\n  }\n}\n\nasync function isImageUri(options: AvatarOptions): Promise<boolean> {\n  try {\n    const res = await getClientFetch(options.client)(options.uri, {\n      method: \"HEAD\",\n    });\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get(\"content-type\");\n      return !!contentType?.startsWith(\"image/\");\n    }\n    return false;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === \"object\" && typeof error.response !== \"undefined\") {\n      return false;\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (Object.hasOwn(globalThis, \"Image\")) {\n      return false;\n    }\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(true);\n      };\n      img.onerror = () => {\n        resolve(false);\n      };\n      img.src = options.uri;\n    });\n  }\n}\n", "import { type Hex, isHex } from \"../encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function encodedLabelToLabelhash(label: string): Hex | null {\n  if (label.length !== 66) {\n    return null;\n  }\n  if (label.indexOf(\"[\") !== 0) {\n    return null;\n  }\n  if (label.indexOf(\"]\") !== 65) {\n    return null;\n  }\n  const hash = `0x${label.slice(1, 65)}`;\n  if (!isHex(hash)) {\n    return null;\n  }\n  return hash;\n}\n", "import { bytesToHex, concat } from \"viem/utils\";\nimport { stringToBytes, toBytes } from \"../encoding/to-bytes.js\";\nimport { keccak256 } from \"../hashing/keccak256.js\";\nimport { encodedLabelToLabelhash } from \"./encodeLabelToLabelhash.js\";\n\n/**\n * @internal\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0);\n  if (!name) {\n    return bytesToHex(result);\n  }\n\n  const labels = name.split(\".\");\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const item = labels[i] as string;\n    const hashFromEncodedLabel = encodedLabelToLabelhash(item);\n    const hashed = hashFromEncodedLabel\n      ? toBytes(hashFromEncodedLabel)\n      : keccak256(stringToBytes(item), \"bytes\");\n    result = keccak256(concat([result, hashed]), \"bytes\");\n  }\n\n  return bytesToHex(result);\n}\n", "import type { Hex } from \"../encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function encodeLabelhash(hash: Hex): `[${string}]` {\n  return `[${hash.slice(2)}]`;\n}\n", "import { type ByteArray, labelhash } from \"viem\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { encodeLabelhash } from \"./encodeLabelhash.js\";\n\n/**\n * Encodes a DNS packet into a ByteArray containing a UDP payload.\n * @param packet\n * @internal\n */\nexport function packetToBytes(packet: string): ByteArray {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, \"\");\n  if (value.length === 0) {\n    return new Uint8Array(1);\n  }\n\n  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);\n\n  let offset = 0;\n  const list = value.split(\".\");\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i] as string;\n    let encoded = stringToBytes(item);\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255) {\n      encoded = stringToBytes(encodeLabelhash(labelhash(item)));\n    }\n    bytes[offset] = encoded.length;\n    bytes.set(encoded, offset + 1);\n    offset += encoded.length + 1;\n  }\n\n  if (bytes.byteLength !== offset + 1) {\n    return bytes.slice(0, offset + 1);\n  }\n\n  return bytes;\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"text\" function.\n */\nexport type TextParams = {\n  name: AbiParameterToPrimitiveType<{ type: \"bytes32\"; name: \"name\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"string\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x59d1d43c\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes32\",\n    name: \"name\",\n  },\n  {\n    type: \"string\",\n    name: \"key\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `text` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `text` method is supported.\n * @extension ENS\n * @example\n * ```ts\n * import { isTextSupported } from \"thirdweb/extensions/ens\";\n *\n * const supported = await isTextSupported(contract);\n * ```\n */\nexport async function isTextSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"text\" function.\n * @param options - The options for the text function.\n * @returns The encoded ABI parameters.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeTextParams } \"thirdweb/extensions/ens\";\n * const result = encodeTextParams({\n *  name: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeTextParams(options: TextParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.name, options.key]);\n}\n\n/**\n * Encodes the \"text\" function into a Hex string with its parameters.\n * @param options - The options for the text function.\n * @returns The encoded hexadecimal string.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeText } \"thirdweb/extensions/ens\";\n * const result = encodeText({\n *  name: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeText(options: TextParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeTextParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the text function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ENS\n * @example\n * ```ts\n * import { decodeTextResult } from \"thirdweb/extensions/ens\";\n * const result = decodeTextResult(\"...\");\n * ```\n */\nexport function decodeTextResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"text\" function on the contract.\n * @param options - The options for the text function.\n * @returns The parsed result of the function call.\n * @extension ENS\n * @example\n * ```ts\n * import { text } from \"thirdweb/extensions/ens\";\n *\n * const result = await text({\n *  contract,\n *  name: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function text(options: BaseTransactionOptions<TextParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.name, options.key],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"resolve\" function.\n */\nexport type ResolveParams = {\n  name: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"name\" }>;\n  data: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"data\" }>;\n};\n\nexport const FN_SELECTOR = \"0x9061b923\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes\",\n    name: \"name\",\n  },\n  {\n    type: \"bytes\",\n    name: \"data\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes\",\n  },\n  {\n    type: \"address\",\n  },\n] as const;\n\n/**\n * Checks if the `resolve` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `resolve` method is supported.\n * @extension ENS\n * @example\n * ```ts\n * import { isResolveSupported } from \"thirdweb/extensions/ens\";\n *\n * const supported = await isResolveSupported(contract);\n * ```\n */\nexport async function isResolveSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"resolve\" function.\n * @param options - The options for the resolve function.\n * @returns The encoded ABI parameters.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeResolveParams } \"thirdweb/extensions/ens\";\n * const result = encodeResolveParams({\n *  name: ...,\n *  data: ...,\n * });\n * ```\n */\nexport function encodeResolveParams(options: ResolveParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.name, options.data]);\n}\n\n/**\n * Encodes the \"resolve\" function into a Hex string with its parameters.\n * @param options - The options for the resolve function.\n * @returns The encoded hexadecimal string.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeResolve } \"thirdweb/extensions/ens\";\n * const result = encodeResolve({\n *  name: ...,\n *  data: ...,\n * });\n * ```\n */\nexport function encodeResolve(options: ResolveParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeResolveParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the resolve function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ENS\n * @example\n * ```ts\n * import { decodeResolveResult } from \"thirdweb/extensions/ens\";\n * const result = decodeResolveResult(\"...\");\n * ```\n */\nexport function decodeResolveResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"resolve\" function on the contract.\n * @param options - The options for the resolve function.\n * @returns The parsed result of the function call.\n * @extension ENS\n * @example\n * ```ts\n * import { resolve } from \"thirdweb/extensions/ens\";\n *\n * const result = await resolve({\n *  contract,\n *  name: ...,\n *  data: ...,\n * });\n *\n * ```\n */\nexport async function resolve(options: BaseTransactionOptions<ResolveParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.name, options.data],\n  });\n}\n", "export const UNIVERSAL_RESOLVER_ADDRESS =\n  \"0xce01f8eee7E479C928F8919abD53E553a36CeF67\";\n", "import { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { namehash } from \"../../utils/ens/namehash.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport {\n  decodeTextResult,\n  encodeText,\n} from \"./__generated__/AddressResolver/read/text.js\";\nimport { resolve } from \"./__generated__/UniversalResolver/read/resolve.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n\n/**\n * @extension ENS\n */\nexport type ResolveTextOptions = {\n  client: ThirdwebClient;\n  name: string;\n  key: string;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves an ENS name and key to the specified record.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveText } from \"thirdweb/extensions/ens\";\n * const twitterUsername = await resolveText({\n *    client,\n *    name: \"vitalik.eth\",\n *    key: \"com.twitter\"\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the text record.\n */\nexport async function resolveText(options: ResolveTextOptions) {\n  const { client, name, key, resolverAddress, resolverChain } = options;\n  return withCache(\n    async () => {\n      const contract = getContract({\n        client,\n        chain: resolverChain || ethereum,\n        address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n      });\n\n      const data = encodeText({ name: namehash(name), key });\n\n      const result = await resolve({\n        contract,\n        name: toHex(packetToBytes(name)),\n        data,\n      });\n\n      if (result[0] === \"0x\") {\n        return null;\n      }\n\n      const record = decodeTextResult(result[0]);\n\n      return record === \"\" ? null : record;\n    },\n    {\n      cacheKey: `ens:text:${name}:${key}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n", "import type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { parseAvatarRecord } from \"../../utils/ens/avatar.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { resolveText } from \"./resolve-text.js\";\n\n/**\n * @extension ENS\n */\nexport type ResolveAvatarOptions = {\n  client: ThirdwebClient;\n  name: string;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves an ENS name to the avatar URL.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveAvatar } from \"thirdweb/extensions/ens\";\n * const address = await resolveAvatar({\n *    client,\n *    name: \"vitalik.eth\",\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the avatar url, or null if not set.\n */\nexport async function resolveAvatar(options: ResolveAvatarOptions) {\n  const { client, name, resolverAddress, resolverChain } = options;\n  return withCache(\n    async () => {\n      const record = await resolveText({\n        client,\n        key: \"avatar\",\n        name,\n        resolverAddress,\n        resolverChain,\n      });\n\n      if (!record) {\n        return null;\n      }\n      try {\n        return parseAvatarRecord({ uri: record, client });\n      } catch (e) {\n        console.error(\"Error parsing avatar record\", e);\n        return null;\n      }\n    },\n    {\n      cacheKey: `ens:avatar:${name}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"reverse\" function.\n */\nexport type ReverseParams = {\n  reverseName: AbiParameterToPrimitiveType<{\n    type: \"bytes\";\n    name: \"reverseName\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xec11c823\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes\",\n    name: \"reverseName\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n  {\n    type: \"address\",\n  },\n  {\n    type: \"address\",\n  },\n  {\n    type: \"address\",\n  },\n] as const;\n\n/**\n * Checks if the `reverse` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `reverse` method is supported.\n * @extension ENS\n * @example\n * ```ts\n * import { isReverseSupported } from \"thirdweb/extensions/ens\";\n *\n * const supported = await isReverseSupported(contract);\n * ```\n */\nexport async function isReverseSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"reverse\" function.\n * @param options - The options for the reverse function.\n * @returns The encoded ABI parameters.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeReverseParams } \"thirdweb/extensions/ens\";\n * const result = encodeReverseParams({\n *  reverseName: ...,\n * });\n * ```\n */\nexport function encodeReverseParams(options: ReverseParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.reverseName]);\n}\n\n/**\n * Encodes the \"reverse\" function into a Hex string with its parameters.\n * @param options - The options for the reverse function.\n * @returns The encoded hexadecimal string.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeReverse } \"thirdweb/extensions/ens\";\n * const result = encodeReverse({\n *  reverseName: ...,\n * });\n * ```\n */\nexport function encodeReverse(options: ReverseParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeReverseParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the reverse function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ENS\n * @example\n * ```ts\n * import { decodeReverseResult } from \"thirdweb/extensions/ens\";\n * const result = decodeReverseResult(\"...\");\n * ```\n */\nexport function decodeReverseResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"reverse\" function on the contract.\n * @param options - The options for the reverse function.\n * @returns The parsed result of the function call.\n * @extension ENS\n * @example\n * ```ts\n * import { reverse } from \"thirdweb/extensions/ens\";\n *\n * const result = await reverse({\n *  contract,\n *  reverseName: ...,\n * });\n *\n * ```\n */\nexport async function reverse(options: BaseTransactionOptions<ReverseParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.reverseName],\n  });\n}\n", "import type { Address } from \"abitype\";\nimport { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { reverse } from \"./__generated__/UniversalResolver/read/reverse.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n\n/**\n * @extension ENS\n */\nexport type ResolveNameOptions = {\n  client: ThirdwebClient;\n  address: Address;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves the primary name for a specified address.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveName } from \"thirdweb/extensions/ens\";\n * const name = await resolveName({\n *    client,\n *    address: \"0x1234...\",\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the Ethereum address.\n */\nexport async function resolveName(options: ResolveNameOptions) {\n  const { client, address, resolverAddress, resolverChain } = options;\n\n  return withCache(\n    async () => {\n      const contract = getContract({\n        client,\n        chain: resolverChain || ethereum,\n        address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n      });\n\n      const reverseName = toHex(\n        packetToBytes(`${address.toLowerCase().substring(2)}.addr.reverse`),\n      );\n\n      const [name, resolvedAddress] = await reverse({\n        contract,\n        reverseName,\n      }).catch((e) => {\n        if (\"data\" in e && e.data === \"0x7199966d\") {\n          return [null, address] as const;\n        }\n        throw e;\n      });\n\n      if (address.toLowerCase() !== resolvedAddress.toLowerCase()) {\n        return null;\n      }\n\n      return name;\n    },\n    {\n      cacheKey: `ens:name:${address}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n", "/**\n * @internal\n */\nexport function shortenString(str: string, extraShort = true) {\n  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(\n    str.length - (extraShort ? 3 : 4),\n  )}`;\n}\n", "import { useQuery } from \"@tanstack/react-query\";\nimport { ethereum } from \"../../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { resolveAvatar } from \"../../../extensions/ens/resolve-avatar.js\";\nimport { resolveName } from \"../../../extensions/ens/resolve-name.js\";\nimport { getWalletInfo } from \"../../../wallets/__generated__/getWalletInfo.js\";\nimport type { Account, Wallet } from \"../../../wallets/interfaces/wallet.js\";\nimport type { WalletInfo } from \"../../../wallets/wallet-info.js\";\nimport type { WalletId } from \"../../../wallets/wallet-types.js\";\nimport { useWalletBalance } from \"../hooks/others/useWalletBalance.js\";\nimport { shortenString } from \"./addresses.js\";\n\n/**\n * Get the ENS name and avatar for an address\n * @param options - the client and address to get the ENS name and avatar for\n * @returns - a query object that resolves to the ENS name\n * @example\n * ```tsx\n * import { useEnsName } from \"thirdweb/react\";\n *\n * const { data: ensName } = useEnsName({\n *  client,\n *  address: \"0x1234...\",\n * });\n * ```\n * @extension ENS\n */\nexport function useEnsName(options: {\n  client: ThirdwebClient;\n  address: string | undefined;\n}) {\n  const { client, address } = options;\n  return useQuery({\n    queryKey: [\"ens-name\", address],\n    enabled: !!address,\n    queryFn: () =>\n      resolveName({\n        client,\n        address: address || \"\",\n        resolverChain: ethereum,\n      }),\n  });\n}\n\n/**\n * Get the ENS avatar for an ENS name\n * @param options - the client and ENS name to get the avatar for\n * @returns - a query object that resolves to the avatar\n * @example\n * ```tsx\n * import { useEnsAvatar } from \"thirdweb/react\";\n *\n * const { data: ensAvatar } = useEnsAvatar({\n *  client,\n *  ensName: \"my-ens-name.eth\",\n * });\n * ```\n * @extension ENS\n */\nexport function useEnsAvatar(options: {\n  client: ThirdwebClient;\n  ensName: string | null | undefined;\n}) {\n  const { client, ensName } = options;\n  return useQuery({\n    queryKey: [\"ens-avatar\", ensName],\n    enabled: !!ensName,\n    queryFn: async () =>\n      resolveAvatar({\n        client,\n        name: ensName || \"\",\n      }),\n  });\n}\n\n/**\n * @internal\n */\nexport function useConnectedWalletDetails(\n  client: ThirdwebClient,\n  walletChain: Chain | undefined,\n  activeAccount: Account | undefined,\n  displayBalanceToken?: Record<number, string>,\n) {\n  const tokenAddress =\n    walletChain && displayBalanceToken\n      ? displayBalanceToken[Number(walletChain.id)]\n      : undefined;\n\n  const ensNameQuery = useEnsName({\n    client,\n    address: activeAccount?.address,\n  });\n\n  const ensAvatarQuery = useEnsAvatar({\n    client,\n    ensName: ensNameQuery.data,\n  });\n\n  const shortAddress = activeAccount?.address\n    ? shortenString(activeAccount.address, false)\n    : \"\";\n\n  const balanceQuery = useWalletBalance({\n    chain: walletChain ? walletChain : undefined,\n    tokenAddress,\n    address: activeAccount?.address,\n    client,\n  });\n\n  const addressOrENS = ensNameQuery.data || shortAddress;\n\n  return {\n    ensNameQuery,\n    ensAvatarQuery,\n    addressOrENS,\n    shortAddress,\n    balanceQuery,\n  };\n}\n\n/**\n * Returns the wallet info for the provided wallet id.\n *\n * @example\n * ```tsx\n * import { useWalletInfo } from \"thirdweb/react\";\n *\n * const { data: walletInfo } = useWalletInfo(\"io.metamask\");\n * console.log(\"Walelt name\", walletInfo?.name);\n * ```\n * @wallet\n */\nexport function useWalletInfo(id: WalletId | undefined) {\n  return useQuery<WalletInfo>({\n    queryKey: [\"wallet-info\", id],\n    queryFn: () => {\n      if (!id) {\n        throw new Error(\"Wallet id is required\");\n      }\n      return getWalletInfo(id, false);\n    },\n    retry: false,\n    refetchOnWindowFocus: false,\n    refetchOnMount: false,\n    enabled: !!id,\n  });\n}\n\n/**\n * Returns the wallet icon for the provided wallet id.\n *\n * @example\n * ```tsx\n * import { useWalletImage } from \"thirdweb/react\";\n *\n * const { data: walletImage } = useWalletImage(\"io.metamask\");\n *\n * return <img src={walletImage} alt=\"MetaMask logo\" />;\n * ```\n *\n * @wallet\n */\nexport function useWalletImage(id: WalletId | undefined) {\n  return useQuery({\n    queryKey: [\"wallet-image\", id],\n    queryFn: () => {\n      if (!id) {\n        throw new Error(\"Wallet id is required\");\n      }\n      return getWalletInfo(id, true);\n    },\n    retry: false,\n    refetchOnWindowFocus: false,\n    refetchOnMount: false,\n    enabled: !!id,\n  });\n}\n\n/**\n * @internal\n */\nexport function hasSponsoredTransactionsEnabled(wallet: Wallet | undefined) {\n  if (!wallet) {\n    return false;\n  }\n  let sponsoredTransactionsEnabled = false;\n  if (wallet && wallet.id === \"smart\") {\n    const options = (wallet as Wallet<\"smart\">).getConfig();\n    if (\"sponsorGas\" in options) {\n      sponsoredTransactionsEnabled = options.sponsorGas;\n    }\n    if (\"gasless\" in options) {\n      sponsoredTransactionsEnabled = options.gasless;\n    }\n  }\n  if (wallet && wallet.id === \"inApp\") {\n    const options = (wallet as Wallet<\"inApp\">).getConfig();\n    if (options && \"smartAccount\" in options && options.smartAccount) {\n      const smartOptions = options.smartAccount;\n      if (\"sponsorGas\" in smartOptions) {\n        sponsoredTransactionsEnabled = smartOptions.sponsorGas;\n      }\n      if (\"gasless\" in smartOptions) {\n        sponsoredTransactionsEnabled = smartOptions.gasless;\n      }\n    }\n  }\n  return sponsoredTransactionsEnabled;\n}\n", "import type { Wallet } from \"../../../wallets/interfaces/wallet.js\";\n\nexport function hasSmartAccount(activeWallet?: Wallet): boolean {\n  const config = activeWallet?.getConfig();\n  return (\n    !!activeWallet &&\n    (activeWallet.id === \"smart\" ||\n      (activeWallet.id === \"inApp\" && !!config && \"smartAccount\" in config))\n  );\n}\n", "import type { Store } from \"./store.js\";\n\nexport type ReadonlyStore<T> = {\n  getValue(): T;\n  subscribe(listener: () => void): () => void;\n};\n\n/**\n * Create a readonly store whose value is computed from other stores\n * @param computation - The function to compute the value of the store\n * @param dependencies - The stores it depends on\n * @example\n * ```ts\n * const foo = computed(() => bar.getValue() + baz.getValue(), [bar, baz]);\n * ```\n * @returns A store object\n */\nexport function computedStore<T>(\n  // pass the values of the dependencies to the computation function\n  computation: () => T,\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any store type\n  dependencies: (Store<any> | ReadonlyStore<any>)[],\n): ReadonlyStore<T> {\n  type Listener = () => void;\n  const listeners = new Set<Listener>();\n\n  let value = computation();\n\n  const notify = () => {\n    for (const listener of listeners) {\n      listener();\n    }\n  };\n\n  const setValue = (newValue: T) => {\n    value = newValue;\n    notify();\n  };\n\n  // when any of the dependencies change, recompute the value and set it\n  for (const store of dependencies) {\n    store.subscribe(() => {\n      setValue(computation());\n    });\n  }\n\n  return {\n    getValue() {\n      return value;\n    },\n    subscribe(listener: Listener) {\n      listeners.add(listener);\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n  };\n}\n", "import type { ReadonlyStore } from \"./computedStore.js\";\nimport type { Store } from \"./store.js\";\n\n/**\n * Run a function whenever dependencies change\n * @param effectFn - Side effect function to run\n * @param dependencies - The stores it depends on\n * @param runOnMount - Whether to run the effect function immediately or not\n * @example\n * ```ts\n * const foo = computed(() => bar.getValue() + baz.getValue(), [bar, baz]);\n * ```\n * @returns A function to stop listening to changes in the dependencies\n */\nexport function effect<T>(\n  // pass the values of the dependencies to the computation function\n  effectFn: () => T,\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any store type\n  dependencies: (Store<any> | ReadonlyStore<any>)[],\n  runOnMount = true,\n) {\n  if (runOnMount) {\n    effectFn();\n  }\n\n  // when any of the dependencies change, recompute the value and set it\n  const unsubscribeList = dependencies.map((store) => {\n    return store.subscribe(() => {\n      effectFn();\n    });\n  });\n\n  return () => {\n    for (const fn of unsubscribeList) {\n      fn();\n    }\n  };\n}\n", "import type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { hasSmartAccount } from \"../../react/core/utils/isSmartWallet.js\";\nimport { computedStore } from \"../../reactive/computedStore.js\";\nimport { effect } from \"../../reactive/effect.js\";\nimport { createStore } from \"../../reactive/store.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport { deleteConnectParamsFromStorage } from \"../../utils/storage/walletStorage.js\";\nimport type { Account, Wallet } from \"../interfaces/wallet.js\";\nimport { smartWallet } from \"../smart/smart-wallet.js\";\nimport type { SmartWalletOptions } from \"../smart/types.js\";\nimport type { WalletId } from \"../wallet-types.js\";\n\ntype WalletIdToConnectedWalletMap = Map<string, Wallet>;\nexport type ConnectionStatus = \"connected\" | \"disconnected\" | \"connecting\";\n\nconst CONNECTED_WALLET_IDS = \"thirdweb:connected-wallet-ids\";\nconst LAST_ACTIVE_EOA_ID = \"thirdweb:active-wallet-id\";\nconst LAST_ACTIVE_CHAIN = \"thirdweb:active-chain\";\n\nexport type ConnectionManager = ReturnType<typeof createConnectionManager>;\nexport type ConnectManagerOptions = {\n  client: ThirdwebClient;\n  accountAbstraction?: SmartWalletOptions;\n  onConnect?: (wallet: Wallet) => void;\n};\n\n/**\n * Create a connection manager for Wallet connections\n * @param storage - An instance of type [`AsyncStorage`](https://portal.thirdweb.com/references/typescript/v5/AsyncStorage)\n * @example\n * ```ts\n * const manager = createConnectionManager();\n * ```\n * @returns A connection manager object\n * @walletUtils\n */\nexport function createConnectionManager(storage: AsyncStorage) {\n  // stores\n\n  // active wallet/account\n  const activeWalletStore = createStore<Wallet | undefined>(undefined);\n  const activeAccountStore = createStore<Account | undefined>(undefined);\n  const activeWalletChainStore = createStore<Chain | undefined>(undefined);\n  const activeWalletConnectionStatusStore =\n    createStore<ConnectionStatus>(\"disconnected\");\n\n  // other connected accounts\n  const walletIdToConnectedWalletMap =\n    createStore<WalletIdToConnectedWalletMap>(new Map());\n\n  const isAutoConnecting = createStore(false);\n\n  const connectedWallets = computedStore(() => {\n    return Array.from(walletIdToConnectedWalletMap.getValue().values());\n  }, [walletIdToConnectedWalletMap]);\n\n  // actions\n  const addConnectedWallet = (wallet: Wallet) => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    if (oldValue.has(wallet.id)) {\n      return;\n    }\n    const newValue = new Map(oldValue);\n    newValue.set(wallet.id, wallet);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n\n  const removeConnectedWallet = (wallet: Wallet) => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    const newValue = new Map(oldValue);\n    newValue.delete(wallet.id);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n\n  const onWalletDisconnect = (wallet: Wallet) => {\n    deleteConnectParamsFromStorage(storage, wallet.id);\n    removeConnectedWallet(wallet);\n\n    // if disconnecting the active wallet\n    if (activeWalletStore.getValue() === wallet) {\n      storage.removeItem(LAST_ACTIVE_EOA_ID);\n      activeAccountStore.setValue(undefined);\n      activeWalletChainStore.setValue(undefined);\n      activeWalletStore.setValue(undefined);\n      activeWalletConnectionStatusStore.setValue(\"disconnected\");\n    }\n  };\n\n  const disconnectWallet = (wallet: Wallet) => {\n    onWalletDisconnect(wallet);\n    wallet.disconnect();\n  };\n\n  // handle the connection logic, but don't set the wallet as active\n  const handleConnection = async (\n    wallet: Wallet,\n    options?: ConnectManagerOptions,\n  ) => {\n    const account = wallet.getAccount();\n    if (!account) {\n      throw new Error(\"Can not set a wallet without an account as active\");\n    }\n\n    const personalWallet = wallet;\n    let activeWallet = personalWallet;\n    const isInAppSmartAccount = hasSmartAccount(wallet);\n    if (options?.accountAbstraction && !isInAppSmartAccount) {\n      activeWallet = smartWallet(options.accountAbstraction);\n      await activeWallet.connect({\n        personalAccount: wallet.getAccount(),\n        client: options.client,\n      });\n    }\n\n    handleSetActiveWallet(activeWallet);\n\n    // add personal wallet to connected wallets list\n    addConnectedWallet(personalWallet);\n\n    if (personalWallet.id !== \"smart\") {\n      await storage.setItem(LAST_ACTIVE_EOA_ID, personalWallet.id);\n    }\n\n    return activeWallet;\n  };\n\n  const connect = async (wallet: Wallet, options?: ConnectManagerOptions) => {\n    // connectedWallet can be either wallet or smartWallet based on\n    const connectedWallet = await handleConnection(wallet, options);\n    options?.onConnect?.(connectedWallet);\n    handleSetActiveWallet(connectedWallet);\n    return connectedWallet;\n  };\n\n  const handleSetActiveWallet = (activeWallet: Wallet) => {\n    const account = activeWallet.getAccount();\n    if (!account) {\n      throw new Error(\"Can not set a wallet without an account as active\");\n    }\n\n    // also add it to connected wallets if it's not already there\n    addConnectedWallet(activeWallet);\n\n    // update active states\n    activeWalletStore.setValue(activeWallet);\n    activeAccountStore.setValue(account);\n    activeWalletChainStore.setValue(activeWallet.getChain());\n    activeWalletConnectionStatusStore.setValue(\"connected\");\n\n    // setup listeners\n\n    const onAccountsChanged = (newAccount: Account) => {\n      activeAccountStore.setValue(newAccount);\n    };\n\n    const unsubAccounts = activeWallet.subscribe(\n      \"accountChanged\",\n      onAccountsChanged,\n    );\n\n    const unsubChainChanged = activeWallet.subscribe(\"chainChanged\", (chain) =>\n      activeWalletChainStore.setValue(chain),\n    );\n    const unsubDisconnect = activeWallet.subscribe(\"disconnect\", () => {\n      handleDisconnect();\n    });\n\n    const handleDisconnect = () => {\n      onWalletDisconnect(activeWallet);\n      unsubAccounts();\n      unsubChainChanged();\n      unsubDisconnect();\n    };\n  };\n\n  const setActiveWallet = async (activeWallet: Wallet) => {\n    handleSetActiveWallet(activeWallet);\n    // do not set smart wallet as last active EOA\n    if (activeWallet.id !== \"smart\") {\n      await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);\n    }\n  };\n\n  // side effects\n\n  effect(\n    () => {\n      const _chain = activeWalletChainStore.getValue();\n      if (_chain) {\n        storage.setItem(LAST_ACTIVE_CHAIN, JSON.stringify(_chain));\n      } else {\n        storage.removeItem(LAST_ACTIVE_CHAIN);\n      }\n    },\n    [activeWalletChainStore],\n    false,\n  );\n\n  // save last connected wallet ids to storage\n  effect(\n    () => {\n      const accounts = connectedWallets.getValue();\n      const ids = accounts.map((acc) => acc?.id).filter((c) => !!c) as string[];\n\n      storage.setItem(CONNECTED_WALLET_IDS, JSON.stringify(ids));\n    },\n    [connectedWallets],\n    false,\n  );\n\n  const switchActiveWalletChain = async (chain: Chain) => {\n    const wallet = activeWalletStore.getValue();\n    if (!wallet) {\n      throw new Error(\"no wallet found\");\n    }\n\n    if (!wallet.switchChain) {\n      throw new Error(\"wallet does not support switching chains\");\n    }\n\n    if (wallet.id === \"smart\") {\n      // also switch personal wallet\n      const personalWalletId = await getStoredActiveWalletId(storage);\n      if (personalWalletId) {\n        const personalWallet = connectedWallets\n          .getValue()\n          .find((w) => w.id === personalWalletId);\n        if (personalWallet) {\n          await personalWallet.switchChain(chain);\n        }\n      }\n      await wallet.switchChain(chain);\n      // reset the active wallet as switch chain recreates a new smart account\n      handleSetActiveWallet(wallet);\n    } else {\n      await wallet.switchChain(chain);\n    }\n\n    // for wallets that dont implement events, just set it manually\n    activeWalletChainStore.setValue(wallet.getChain());\n  };\n\n  return {\n    // account\n    activeWalletStore: activeWalletStore,\n    activeAccountStore: activeAccountStore,\n    connectedWallets,\n    addConnectedWallet,\n    disconnectWallet,\n    setActiveWallet,\n    connect,\n    handleConnection,\n    activeWalletChainStore: activeWalletChainStore,\n    switchActiveWalletChain,\n    activeWalletConnectionStatusStore: activeWalletConnectionStatusStore,\n    isAutoConnecting,\n    removeConnectedWallet,\n  };\n}\n\n/**\n *\n * @internal\n */\nexport async function getStoredConnectedWalletIds(\n  storage: AsyncStorage,\n): Promise<string[] | null> {\n  try {\n    const value = await storage.getItem(CONNECTED_WALLET_IDS);\n    if (value) {\n      return JSON.parse(value) as string[];\n    }\n    return [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * @internal\n */\nexport async function getStoredActiveWalletId(\n  storage: AsyncStorage,\n): Promise<WalletId | null> {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_EOA_ID);\n    if (value) {\n      return value as WalletId;\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * @internal\n */\nexport async function getLastConnectedChain(\n  storage: AsyncStorage,\n): Promise<Chain | null> {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_CHAIN);\n    if (value) {\n      return JSON.parse(value) as Chain;\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n", "\"use client\";\nimport { useEffect, useState } from \"react\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport { getWalletInfo } from \"../../../../wallets/__generated__/getWalletInfo.js\";\nimport { getInstalledWalletProviders } from \"../../../../wallets/injected/mipdStore.js\";\nimport { getStoredActiveWalletId } from \"../../../../wallets/manager/index.js\";\nimport type { WalletId } from \"../../../../wallets/wallet-types.js\";\nimport { radius } from \"../../../core/design-system/index.js\";\nimport { useActiveWallet } from \"../../../core/hooks/wallets/useActiveWallet.js\";\nimport {\n  appleIconUri,\n  discordIconUri,\n  emailIcon,\n  facebookIconUri,\n  farcasterIconUri,\n  genericWalletIcon,\n  googleIconUri,\n  passkeyIcon,\n  phoneIcon,\n  telegramIconUri,\n} from \"../../../core/utils/socialIcons.js\";\nimport { getLastAuthProvider } from \"../../../core/utils/storage.js\";\nimport { useWalletImage } from \"../../../core/utils/wallet.js\";\nimport { Img } from \"./Img.js\";\n\n/**\n * @internal\n */\nexport function WalletImage(props: {\n  id: WalletId;\n  size: string;\n  client: ThirdwebClient;\n  style?: React.CSSProperties;\n}) {\n  const [image, setImage] = useState<string | undefined>(undefined);\n  const activeWallet = useActiveWallet();\n  useEffect(() => {\n    async function fetchImage() {\n      // show EOA icon for external wallets\n      // show auth provider icon for in-app wallets\n      // show the admin EOA icon for smart\n      const storage = webLocalStorage;\n      let activeEOAId = props.id;\n      if (props.id === \"smart\") {\n        const storedId = await getStoredActiveWalletId(storage);\n        if (storedId) {\n          activeEOAId = storedId;\n        }\n      }\n      let image: string | undefined;\n\n      if (\n        activeEOAId === \"inApp\" &&\n        activeWallet &&\n        (activeWallet.id === \"inApp\" || activeWallet.id === \"smart\")\n      ) {\n        // when showing an active wallet icon - check last auth provider and override the IAW icon\n        const lastAuthProvider = await getLastAuthProvider(storage);\n        switch (lastAuthProvider) {\n          case \"google\":\n            image = googleIconUri;\n            break;\n          case \"apple\":\n            image = appleIconUri;\n            break;\n          case \"facebook\":\n            image = facebookIconUri;\n            break;\n          case \"phone\":\n            image = phoneIcon;\n            break;\n          case \"email\":\n            image = emailIcon;\n            break;\n          case \"passkey\":\n            image = passkeyIcon;\n            break;\n          case \"discord\":\n            image = discordIconUri;\n            break;\n          case \"farcaster\":\n            image = farcasterIconUri;\n            break;\n          case \"telegram\":\n            image = telegramIconUri;\n            break;\n        }\n      } else {\n        const mipdImage = getInstalledWalletProviders().find(\n          (x) => x.info.rdns === activeEOAId,\n        )?.info.icon;\n\n        if (mipdImage) {\n          image = mipdImage;\n        } else {\n          image = await getWalletInfo(activeEOAId, true);\n        }\n      }\n\n      setImage(image);\n    }\n    fetchImage();\n  }, [props.id, activeWallet]);\n\n  if (image) {\n    return (\n      <Img\n        src={image}\n        width={props.size}\n        height={props.size}\n        loading=\"eager\"\n        client={props.client}\n        style={{\n          borderRadius: radius.md,\n          ...props.style,\n        }}\n      />\n    );\n  }\n\n  return (\n    <WalletImageQuery id={props.id} size={props.size} client={props.client} />\n  );\n}\n\nfunction WalletImageQuery(props: {\n  id: WalletId;\n  size: string;\n  client: ThirdwebClient;\n}) {\n  const walletImage = useWalletImage(props.id);\n\n  if (walletImage.isFetched && !walletImage.data) {\n    return (\n      <Img\n        client={props.client}\n        src={genericWalletIcon}\n        width={props.size}\n        height={props.size}\n      />\n    );\n  }\n\n  return (\n    <Img\n      client={props.client}\n      src={walletImage.isLoading ? undefined : walletImage.data}\n      fallbackImage={genericWalletIcon}\n      width={props.size}\n      height={props.size}\n      loading=\"eager\"\n      style={{\n        borderRadius: radius.md,\n      }}\n    />\n  );\n}\n"],
  "mappings": "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",
  "names": ["resolve", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "import_react", "image", "_jsx"]
}
