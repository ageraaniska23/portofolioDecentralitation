{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/bigint.ts", "../../thirdweb/src/transaction/actions/zksync/getEip721Domain.ts", "../../thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts", "../../thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts", "../../thirdweb/src/wallets/smart/types.ts", "../../thirdweb/src/wallets/smart/lib/utils.ts", "../../thirdweb/src/wallets/smart/lib/bundler.ts", "../../thirdweb/src/wallets/smart/lib/calls.ts", "../../thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getNonce.ts", "../../thirdweb/src/wallets/smart/lib/paymaster.ts", "../../thirdweb/src/wallets/smart/lib/userop.ts", "../../thirdweb/src/wallets/smart/index.ts"],
  "sourcesContent": ["import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n", "import type { TransactionSerializable } from \"viem\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type {\n  EIP712SerializedTransaction,\n  EIP712TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP712TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP712SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    // TODO suport factoryDeps\n    factoryDeps: [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n", "import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\nexport type SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit);\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n", "import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n", "import type { Address } from \"abitype\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\n\nexport type SmartWalletOptions = Prettify<\n  {\n    chain: Chain; // TODO consider making default chain optional\n    factoryAddress?: string;\n    overrides?: {\n      bundlerUrl?: string;\n      accountAddress?: string;\n      accountSalt?: string;\n      entrypointAddress?: string;\n      erc20Paymaster?: {\n        address: string;\n        token: string;\n      };\n      paymaster?: (userOp: UserOperation) => Promise<PaymasterResult>;\n      predictAddress?: (factoryContract: ThirdwebContract) => Promise<string>;\n      createAccount?: (\n        factoryContract: ThirdwebContract,\n      ) => PreparedTransaction;\n      execute?: (\n        accountContract: ThirdwebContract,\n        transaction: SendTransactionOption,\n      ) => PreparedTransaction;\n      executeBatch?: (\n        accountContract: ThirdwebContract,\n        transactions: SendTransactionOption[],\n      ) => PreparedTransaction;\n      getAccountNonce?: (accountContract: ThirdwebContract) => Promise<bigint>;\n    };\n  } & (\n    | {\n        /**\n         * @deprecated use 'sponsorGas' instead\n         */\n        gasless: boolean;\n      }\n    | {\n        sponsorGas: boolean;\n      }\n  )\n>;\n\n// internal type\nexport type SmartAccountOptions = Prettify<\n  Omit<SmartWalletOptions, \"chain\" | \"gasless\" | \"sponsorGas\"> & {\n    chain: Chain;\n    sponsorGas: boolean;\n    personalAccount: Account;\n    factoryContract: ThirdwebContract;\n    accountContract: ThirdwebContract;\n    client: ThirdwebClient;\n  }\n>;\n\nexport type BundlerOptions = {\n  bundlerUrl?: string;\n  entrypointAddress?: string;\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\nexport type SmartWalletConnectionOptions = {\n  personalAccount: Account;\n  client: ThirdwebClient;\n  chain?: Chain;\n};\n\nexport type UserOperation = {\n  sender: Address;\n  nonce: bigint;\n  initCode: Hex | Uint8Array;\n  callData: Hex | Uint8Array;\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  paymasterAndData: Hex | Uint8Array;\n  signature: Hex | Uint8Array;\n};\n\nexport type UserOperationHexed = {\n  sender: Address;\n  nonce: Hex;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type PaymasterResult = {\n  paymasterAndData: string;\n  preVerificationGas?: bigint;\n  verificationGasLimit?: bigint;\n  callGasLimit?: bigint;\n};\n\nexport type EstimationResult = {\n  preVerificationGas: bigint;\n  verificationGas: bigint;\n  verificationGasLimit: bigint;\n  callGasLimit: bigint;\n};\n\nexport type GasPriceResult = {\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n};\n\nexport type PmTransactionData = {\n  paymaster: Address;\n  paymasterInput: Hex;\n};\n\nexport type UserOperationReceipt = {\n  receipt: TransactionReceipt;\n  logs: TransactionReceipt[\"logs\"];\n  userOpHash: Hex;\n  entryPoint: Address;\n  sender: Address;\n  nonce: bigint;\n  paymaster: Address;\n  actualGasUsed: bigint;\n  actualGasCost: bigint;\n  success: boolean;\n};\n\nexport function formatUserOperationReceipt(\n  userOpReceiptRaw: UserOperationReceipt,\n) {\n  const { receipt: transactionReceipt } = userOpReceiptRaw;\n\n  const receipt = {\n    ...transactionReceipt,\n    transactionHash: transactionReceipt.transactionHash,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex,\n    status: transactionReceipt.status,\n    type: transactionReceipt.type,\n  } as TransactionReceipt;\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n\n  const userOpReceipt = {\n    ...userOpReceiptRaw,\n    receipt,\n    userOpHash: userOpReceiptRaw.userOpHash,\n    actualGasCost: BigInt(userOpReceiptRaw.actualGasCost),\n    actualGasUsed: BigInt(userOpReceiptRaw.actualGasUsed),\n    nonce: BigInt(userOpReceiptRaw.nonce),\n  } as UserOperationReceipt;\n  return userOpReceipt;\n}\n", "import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport { isHex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type { UserOperation, UserOperationHexed } from \"../types.js\";\n\nexport const generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport const randomNonce = () => {\n  return BigInt(\n    concat([numberToHex(generateRandomUint192()), \"0x0000000000000000\"]),\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(userOp: UserOperation): UserOperationHexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationHexed;\n}\n\nexport function isNativeAAChain(chain: Chain) {\n  return chain.id === 324 || chain.id === 300 || chain.id === 302;\n}\n", "import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport {\n  type BundlerOptions,\n  type EstimationResult,\n  type GasPriceResult,\n  type PmTransactionData,\n  type UserOperation,\n  type UserOperationReceipt,\n  formatUserOperationReceipt,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: hexToBigInt(res.verificationGas),\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n  };\n}\n\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<TransactionReceipt | undefined> {\n  const res = await getUserOpReceiptRaw(args);\n\n  if (!res) {\n    return undefined;\n  }\n\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(\n        `UserOp failed at txHash: ${res.receipt.transactionHash}`,\n      );\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.receipt.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<UserOperationReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    options: args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  return formatUserOperationReceipt(res as UserOperationReceipt);\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const bundlerUrl = options.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = JSON.stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n", "import type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const extraData = stringToHex(accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, extraData],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract);\n  }\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, stringToHex(accountSalt ?? \"\")],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getNonce\" function.\n */\nexport type GetNonceParams = {\n  sender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"sender\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"uint192\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x35567e1a\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"sender\",\n  },\n  {\n    type: \"uint192\",\n    name: \"key\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n    name: \"nonce\",\n  },\n] as const;\n\n/**\n * Checks if the `getNonce` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `getNonce` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetNonceSupported } from \"thirdweb/extensions/erc4337\";\n *\n * const supported = await isGetNonceSupported(contract);\n * ```\n */\nexport async function isGetNonceSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getNonce\" function.\n * @param options - The options for the getNonce function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonceParams } \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonceParams({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonceParams(options: GetNonceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.sender, options.key]);\n}\n\n/**\n * Encodes the \"getNonce\" function into a Hex string with its parameters.\n * @param options - The options for the getNonce function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonce } \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonce({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonce(options: GetNonceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetNonceParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getNonce function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetNonceResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetNonceResult(\"...\");\n * ```\n */\nexport function decodeGetNonceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getNonce\" function on the contract.\n * @param options - The options for the getNonce function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getNonce } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getNonce({\n *  contract,\n *  sender: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function getNonce(\n  options: BaseTransactionOptions<GetNonceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.sender, options.key],\n  });\n}\n", "import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport type { PaymasterResult, UserOperation } from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultPaymasterUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Get paymaster and data details for a user operation.\n * @param args - The userOp and options\n * @returns - The paymaster and data details for the user operation.\n * @example\n * ```ts\n * import { getPaymasterAndData } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const paymasterAndData = await getPaymasterAndData({\n *  userOp,\n *  client,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperation;\n  client: ThirdwebClient;\n  chain: Chain;\n  entrypointAddress?: string;\n  paymasterOverride?: (userOp: UserOperation) => Promise<PaymasterResult>;\n}): Promise<PaymasterResult> {\n  const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;\n\n  if (paymasterOverride) {\n    return paymasterOverride(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const paymasterUrl = getDefaultPaymasterUrl(chain);\n  const entrypoint = entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n", "import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport type {\n  BundlerOptions,\n  SmartWalletOptions,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  estimateUserOpGas,\n  getUserOpGasFees,\n  getUserOpReceipt,\n} from \"./bundler.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\n\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n    timeoutMs?: number;\n    intervalMs?: number;\n  },\n): Promise<TransactionReceipt> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args: {\n  transaction: PreparedTransaction;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n}): Promise<UserOperation> {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n  const isDeployed = await isContractDeployed(accountContract);\n  const initCode = isDeployed\n    ? \"0x\"\n    : await getAccountInitCode({\n        factoryContract: factoryContract,\n        adminAddress,\n        accountSalt: overrides?.accountSalt,\n        createAccountOverride: overrides?.createAccount,\n      });\n  const callData = await encode(executeTx);\n  const bundlerOptions = {\n    client,\n    chain,\n    entrypointAddress: overrides?.entrypointAddress,\n  };\n\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n  const bundlerUrl = overrides?.bundlerUrl ?? getDefaultBundlerUrl(chain);\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n\n  const nonce = await getAccountNonce({\n    accountContract,\n    chain,\n    client,\n    entrypointAddress: overrides?.entrypointAddress,\n    getNonceOverride: overrides?.getAccountNonce,\n  });\n\n  const partialOp: UserOperation = {\n    sender: accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    });\n    const paymasterAndData = paymasterResult.paymasterAndData;\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster,\n        });\n        if (\n          paymasterResult2.paymasterAndData &&\n          paymasterResult2.paymasterAndData !== \"0x\"\n        ) {\n          partialOp.paymasterAndData = paymasterResult2.paymasterAndData as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\",\n  };\n}\n\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args: {\n  userOp: UserOperation;\n  chain: Chain;\n  entrypointAddress?: string;\n  adminAccount: Account;\n}): Promise<UserOperation> {\n  const { userOp, chain, entrypointAddress, adminAccount } = args;\n  const userOpHash = getUserOpHash({\n    userOp,\n    entryPoint: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n    chainId: chain.id,\n  });\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): Promise<Hex> {\n  const { factoryContract, adminAddress, accountSalt, createAccountOverride } =\n    options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\nasync function getAccountNonce(options: {\n  accountContract: ThirdwebContract;\n  chain: Chain;\n  client: ThirdwebClient;\n  entrypointAddress?: string;\n  getNonceOverride?: (accountContract: ThirdwebContract) => Promise<bigint>;\n}) {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride,\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client,\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address,\n  });\n}\n\n/**\n * Get the hash of a user operation.\n * @param args - The user operation, entrypoint address, and chain ID\n * @returns - The hash of the user operation\n * @walletUtils\n */\nfunction getUserOpHash(args: {\n  userOp: UserOperation;\n  entryPoint: string;\n  chainId: number;\n}): Hex {\n  const { userOp, entryPoint, chainId } = args;\n  const hashedInitCode = keccak256(userOp.initCode);\n  const hashedCallData = keccak256(userOp.callData);\n  const hashedPaymasterAndData = keccak256(userOp.paymasterAndData);\n\n  const packedUserOp = encodeAbiParameters(\n    [\n      { type: \"address\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n      { type: \"bytes32\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n    ],\n    [\n      userOp.sender,\n      userOp.nonce,\n      hashedInitCode,\n      hashedCallData,\n      userOp.callGasLimit,\n      userOp.verificationGasLimit,\n      userOp.preVerificationGas,\n      userOp.maxFeePerGas,\n      userOp.maxPriorityFeePerGas,\n      hashedPaymasterAndData,\n    ],\n  );\n  const encoded = encodeAbiParameters(\n    [{ type: \"bytes32\" }, { type: \"address\" }, { type: \"uint256\" }],\n    [keccak256(packedUserOp), entryPoint, BigInt(chainId)],\n  );\n  return keccak256(encoded);\n}\n", "import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n  maxUint96,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { concatHex } from \"../../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { DEFAULT_ACCOUNT_FACTORY } from \"./lib/constants.js\";\nimport {\n  createUnsignedUserOp,\n  signUserOp,\n  waitForUserOpReceipt,\n} from \"./lib/userop.js\";\nimport { isNativeAAChain } from \"./lib/utils.js\";\nimport type {\n  PaymasterResult,\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n  UserOperation,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nexport const personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const factoryAddress = options.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY;\n  const chain = connectChain ?? options.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (isNativeAAChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: personalAccount.address,\n    predictAddressOverride: options.overrides?.predictAddress,\n    accountSalt: options.overrides?.accountSalt,\n    accountAddress: options.overrides?.accountAddress,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}. Are you on the right chain?`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account: Account = {\n    address: getAddress(accountContract.address),\n    async sendTransaction(transaction: SendTransactionOption) {\n      // if erc20 paymaster - check allowance and approve if needed\n      const erc20Paymaster = options.overrides?.erc20Paymaster;\n      let paymasterOverride:\n        | undefined\n        | ((userOp: UserOperation) => Promise<PaymasterResult>) = undefined;\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options,\n        });\n        const paymasterCallback = async (): Promise<PaymasterResult> => {\n          return {\n            paymasterAndData: concatHex([\n              erc20Paymaster.address as Hex,\n              erc20Paymaster?.token as Hex,\n            ]),\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      }\n      const executeTx = prepareExecute({\n        accountContract,\n        transaction,\n        executeOverride: options.overrides?.execute,\n      });\n      return _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride,\n          },\n        },\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        transactions,\n        executeBatchOverride: options.overrides?.executeBatch,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n  };\n  return account;\n}\n\nasync function approveERC20(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  erc20Paymaster: {\n    address: string;\n    token: string;\n  };\n}) {\n  const { accountContract, erc20Paymaster, options } = args;\n  const tokenAddress = erc20Paymaster.token;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client,\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.address,\n  });\n\n  if (accountAllowance > 0n) {\n    return;\n  }\n\n  const approveTx = approve({\n    contract: tokenContract,\n    spender: erc20Paymaster.address,\n    amountWei: maxUint96 - 1n,\n  });\n  const transaction = await toSerializableTransaction({\n    transaction: approveTx,\n    from: accountContract.address,\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    transaction,\n    executeOverride: options.overrides?.execute,\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        erc20Paymaster: undefined,\n      },\n    },\n  });\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            chain,\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          chain,\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract: options.factoryContract,\n    accountContract: options.accountContract,\n    adminAddress: options.personalAccount.address,\n    sponsorGas: options.sponsorGas,\n    overrides: options.overrides,\n  });\n  const signedUserOp = await signUserOp({\n    chain: options.chain,\n    adminAccount: options.personalAccount,\n    entrypointAddress: options.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  const userOpHash = await bundleUserOp({\n    options,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    ...options,\n    userOpHash,\n  });\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n"],
  "mappings": "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",
  "names": ["predictAddress", "error", "isContractDeployed", "readContract", "encodeAbiParameters"]
}
