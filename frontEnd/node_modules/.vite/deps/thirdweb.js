import {
  eth_estimateGas
} from "./chunk-ND3TNMCQ.js";
import {
  eth_getTransactionCount
} from "./chunk-6XETUKRO.js";
import {
  eth_getLogs,
  getBuyWithCryptoHistory,
  getContractEvents,
  isBaseTransactionOptions,
  simulateTransaction,
  watchContractEvents
} from "./chunk-VGFFALND.js";
import {
  sendBatchTransaction
} from "./chunk-ONHLR6UH.js";
import {
  estimateGasCost,
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus
} from "./chunk-TJGHGGIC.js";
import {
  sendAndConfirmTransaction
} from "./chunk-25UT6ZS2.js";
import {
  eth_blockNumber,
  eth_getTransactionReceipt,
  waitForReceipt,
  watchBlockNumber
} from "./chunk-OTOBMETN.js";
import {
  parseEventLogs,
  prepareEvent
} from "./chunk-P67K46QJ.js";
import "./chunk-HO6P54JG.js";
import "./chunk-YAPA4KI3.js";
import {
  prepareContractCall
} from "./chunk-OVEQXALL.js";
import {
  ADDRESS_ZERO,
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS
} from "./chunk-F2NDM2JU.js";
import {
  concatHex
} from "./chunk-HIZG7GSI.js";
import "./chunk-WWY7S4YD.js";
import {
  serializeTransaction,
  signTransaction,
  trim
} from "./chunk-Z3BOV34S.js";
import {
  eth_getBalance
} from "./chunk-OULA2JUL.js";
import {
  sendTransaction
} from "./chunk-5CJUBOTY.js";
import "./chunk-DVPCWDY6.js";
import "./chunk-OSZAYZBM.js";
import {
  estimateGas,
  eth_gasPrice,
  eth_maxPriorityFeePerGas,
  getGasPrice,
  resolveContractAbi,
  toSerializableTransaction
} from "./chunk-S2KMC4ZU.js";
import {
  eth_getBlockByNumber
} from "./chunk-RQ5H3BEW.js";
import "./chunk-2FH4XCFL.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import "./chunk-VYA3UASK.js";
import "./chunk-PZWOPBWI.js";
import {
  fromGwei,
  toEther,
  toTokens,
  toUnits,
  toWei
} from "./chunk-HAADYJEF.js";
import {
  prepareTransaction
} from "./chunk-WAYCTEWF.js";
import {
  eth_getStorageAt
} from "./chunk-SY6M73X4.js";
import {
  encode
} from "./chunk-GEF6DW5R.js";
import {
  getContract
} from "./chunk-V4R6W4TB.js";
import {
  eth_getCode
} from "./chunk-FPO5TL63.js";
import {
  eth_call,
  readContract
} from "./chunk-BF6IWIHR.js";
import {
  serializeSignature
} from "./chunk-4OMQ45VH.js";
import {
  getRpcClient
} from "./chunk-KFTJWVLQ.js";
import "./chunk-7IZG4EP5.js";
import {
  encodeAbiParameters
} from "./chunk-3UYCMIWJ.js";
import {
  getAddress,
  isAddress
} from "./chunk-UV67MG5D.js";
import {
  formatBlock,
  formatTransaction,
  hashTypedData
} from "./chunk-JMJMW6FX.js";
import {
  boolToBytes,
  hexToBytes,
  keccak256,
  numberToBytes,
  stringToBytes,
  toBytes
} from "./chunk-CY3CMUVN.js";
import {
  assertSize,
  boolToHex,
  fromHex,
  hexToBigInt,
  hexToBool,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isHex,
  numberToHex,
  padHex,
  stringToHex,
  toHex,
  uint8ArrayToHex
} from "./chunk-BNK74YTA.js";
import "./chunk-GDDTQ4UI.js";
import {
  encodeDeployData,
  sliceHex
} from "./chunk-IAQW7B5J.js";
import "./chunk-Z2F5LG57.js";
import {
  equalBytes
} from "./chunk-L46BJXKD.js";
import {
  sha256
} from "./chunk-EWAXOTDC.js";
import "./chunk-TEQAYQEZ.js";
import "./chunk-JCHRT6I2.js";
import {
  defineChain
} from "./chunk-SYYDPSNZ.js";
import "./chunk-MHFR2GDE.js";
import "./chunk-SUMWJFR6.js";
import "./chunk-EZ4JTQAA.js";
import {
  LruMap
} from "./chunk-SHWHM7JY.js";
import "./chunk-256EKJAK.js";

// node_modules/thirdweb/dist/esm/utils/hashing/sha256.js
function sha2562(value, to) {
  const bytes = sha256(isHex(value, { strict: false }) ? hexToUint8Array(value) : value);
  if (to === "bytes") {
    return bytes;
  }
  return uint8ArrayToHex(bytes);
}

// node_modules/thirdweb/dist/esm/utils/client-id.js
var cache = new LruMap(4096);
function computeClientIdFromSecretKey(secretKey) {
  if (cache.has(secretKey)) {
    return cache.get(secretKey);
  }
  const cId = sha2562(stringToBytes(secretKey)).slice(2, 34);
  cache.set(secretKey, cId);
  return cId;
}

// node_modules/thirdweb/dist/esm/client/client.js
function createThirdwebClient(options) {
  const { clientId, secretKey, ...rest } = options;
  if (secretKey) {
    return {
      ...rest,
      clientId: computeClientIdFromSecretKey(secretKey),
      secretKey
    };
  }
  if (clientId) {
    return {
      ...rest,
      clientId: options.clientId,
      secretKey: void 0
    };
  }
  throw new Error("clientId or secretKey must be provided");
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByHash.js
async function eth_getBlockByHash(request, params) {
  const includeTransactions = params.includeTransactions ?? false;
  const block = await request({
    method: "eth_getBlockByHash",
    params: [params.blockHash, includeTransactions]
  });
  if (!block) {
    throw new Error("Block not found");
  }
  return formatBlock(block);
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getTransactionByHash.js
async function eth_getTransactionByHash(request, params) {
  const receipt = await request({
    method: "eth_getTransactionByHash",
    params: [params.hash]
  });
  if (!receipt) {
    throw new Error("Transaction not found.");
  }
  return formatTransaction(receipt);
}

// node_modules/thirdweb/dist/esm/transaction/resolve-method.js
function resolveMethod(method) {
  return async (contract) => {
    const resolvedAbi = await resolveContractAbi(contract);
    const abiFunction = resolvedAbi.find((item) => {
      if (item.type !== "function") {
        return false;
      }
      return item.name === method;
    });
    if (!abiFunction) {
      throw new Error(`could not find function with name "${method}" in abi`);
    }
    return abiFunction;
  };
}

// node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js
function fromBytes(bytes, toOrOpts) {
  const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
  switch (opts.to) {
    case "number":
      return bytesToNumber(bytes, opts);
    case "bigint":
      return bytesToBigInt(bytes, opts);
    case "boolean":
      return bytesToBool(bytes, opts);
    case "string":
      return bytesToString(bytes, opts);
    default:
      return uint8ArrayToHex(bytes, opts);
  }
}
function bytesToBigInt(bytes, opts = {}) {
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
  }
  const hex = uint8ArrayToHex(bytes, opts);
  return hexToBigInt(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes);
  }
  if (bytes.length > 1 || bytes[0] && bytes[0] > 1) {
    throw new Error(`Invalid boolean representation: ${bytes}`);
  }
  return Boolean(bytes[0]);
}
function bytesToNumber(bytes, opts = {}) {
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
  }
  const hex = uint8ArrayToHex(bytes, opts);
  return hexToNumber(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}

// node_modules/thirdweb/dist/esm/auth/constants.js
var ERC_6492_MAGIC_VALUE = "0x6492649264926492649264926492649264926492649264926492649264926492";
var universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
var universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

// node_modules/thirdweb/dist/esm/auth/is-erc6492-signature.js
function isErc6492Signature(signature) {
  return sliceHex(signature, -32) === ERC_6492_MAGIC_VALUE;
}

// node_modules/thirdweb/dist/esm/auth/serialize-erc6492-signature.js
function serializeErc6492Signature({ address, data, signature }) {
  return concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
    ERC_6492_MAGIC_VALUE
  ]);
}

// node_modules/thirdweb/dist/esm/auth/verify-hash.js
async function verifyHash({ hash, signature, address, client, chain, accountFactory }) {
  const signatureHex = (() => {
    if (isHex(signature))
      return signature;
    if (typeof signature === "object" && "r" in signature && "s" in signature)
      return serializeSignature(signature);
    if (signature instanceof Uint8Array)
      return fromBytes(signature, "hex");
    throw new Error(`Invalid signature type for signature ${signature}: ${typeof signature}`);
  })();
  const wrappedSignature = await (async () => {
    if (!accountFactory)
      return signatureHex;
    if (isErc6492Signature(signatureHex))
      return signatureHex;
    return serializeErc6492Signature({
      address: accountFactory.address,
      data: accountFactory.verificationCalldata,
      signature: signatureHex
    });
  })();
  const verificationData = encodeDeployData({
    abi: universalSignatureValidatorAbi,
    args: [address, hash, wrappedSignature],
    bytecode: universalSignatureValidatorByteCode
  });
  const rpcRequest = getRpcClient({
    chain,
    client
  });
  try {
    const result = await eth_call(rpcRequest, {
      data: verificationData
    });
    const hexResult = isHex(result) ? toBytes(result) : result;
    return equalBytes(hexResult, toBytes("0x1"));
  } catch (error) {
    return false;
  }
}

// node_modules/thirdweb/dist/esm/auth/verify-typed-data.js
async function verifyTypedData({ address, signature, client, chain, accountFactory, message, domain, primaryType, types }) {
  const messageHash = hashTypedData({
    message,
    domain,
    primaryType,
    types
  });
  return verifyHash({
    hash: messageHash,
    signature,
    address,
    chain,
    client,
    accountFactory
  });
}
export {
  ADDRESS_ZERO,
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS,
  boolToBytes,
  boolToHex,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  concatHex,
  createThirdwebClient,
  defineChain,
  encode,
  estimateGas,
  estimateGasCost,
  eth_blockNumber,
  eth_call,
  eth_estimateGas,
  eth_gasPrice,
  eth_getBalance,
  eth_getBlockByHash,
  eth_getBlockByNumber,
  eth_getCode,
  eth_getLogs,
  eth_getStorageAt,
  eth_getTransactionByHash,
  eth_getTransactionCount,
  eth_getTransactionReceipt,
  eth_maxPriorityFeePerGas,
  eth_sendRawTransaction,
  fromBytes,
  fromGwei,
  fromHex,
  getAddress,
  getBuyWithCryptoHistory,
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus,
  getContract,
  getContractEvents,
  getGasPrice,
  getRpcClient,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isAddress,
  isBaseTransactionOptions,
  isHex,
  keccak256,
  numberToBytes,
  numberToHex,
  padHex,
  parseEventLogs,
  prepareContractCall,
  prepareEvent,
  prepareTransaction,
  readContract,
  resolveMethod,
  sendAndConfirmTransaction,
  sendBatchTransaction,
  sendTransaction,
  serializeTransaction,
  sha2562 as sha256,
  signTransaction,
  simulateTransaction,
  stringToBytes,
  stringToHex,
  toBytes,
  toEther,
  toHex,
  toSerializableTransaction,
  toTokens,
  toUnits,
  toWei,
  uint8ArrayToHex,
  verifyTypedData,
  waitForReceipt,
  watchBlockNumber,
  watchContractEvents
};
//# sourceMappingURL=thirdweb.js.map
