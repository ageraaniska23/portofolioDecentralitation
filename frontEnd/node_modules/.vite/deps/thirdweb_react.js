import {
  getListing
} from "./chunk-KUAAABIW.js";
import {
  getApprovalForTransaction
} from "./chunk-QLF4PN2C.js";
import {
  getContractMetadata
} from "./chunk-ZLYJGTLV.js";
import {
  AutoConnect,
  BuyScreen,
  ConnectButton,
  ConnectModalContent,
  ConnectModal_default,
  DynamicHeight,
  LazyBuyScreen,
  MediaRenderer,
  Modal,
  SetRootElementContext,
  canFitWideModal,
  defaultTokens,
  getConnectLocale,
  getDefaultToken,
  getDefaultWallets,
  getPostOnRampQuote,
  invalidateWalletBalance,
  useActiveWalletChain,
  useActiveWalletConnectionStatus,
  useAutoConnect,
  useBuyHistory,
  useBuyWithCryptoQuote,
  useBuyWithCryptoStatus,
  useBuyWithFiatQuote,
  useBuyWithFiatStatus,
  useChainExplorers,
  useChainMetadata,
  useConnect,
  useConnectLocale,
  useConnectedWallets,
  useDisconnect,
  useNetworkSwitcherModal,
  usePreloadWalletProviders,
  useSetActiveWallet,
  useSetActiveWalletConnectionStatus,
  useSiweAuth,
  useSwitchActiveWalletChain,
  useWaitForReceipt,
  useWalletDetailsModal
} from "./chunk-IV5RXYAW.js";
import {
  AccentFailIcon
} from "./chunk-BMUKMGO7.js";
import {
  LoadingScreen,
  modalMaxWidthCompact,
  modalMaxWidthWide,
  reservedScreens,
  useActiveAccount,
  useSetupScreen,
  wideModalMaxHeight
} from "./chunk-PA2HBZIL.js";
import "./chunk-V6YGPRLZ.js";
import "./chunk-SHABKKZR.js";
import {
  Spinner,
  WalletUIStatesProvider
} from "./chunk-2755FUD5.js";
import {
  isERC721
} from "./chunk-2QIJTAOJ.js";
import {
  isERC1155
} from "./chunk-BEF2BQNQ.js";
import "./chunk-L7TMFI52.js";
import "./chunk-ZQQ3HD5F.js";
import {
  createConnectionManager,
  useActiveWallet,
  useEnsAvatar,
  useEnsName,
  useWalletBalance,
  useWalletImage,
  useWalletInfo
} from "./chunk-JPZW4FOA.js";
import {
  Button,
  ButtonLink,
  CheckCircledIcon,
  ConnectionManagerCtx,
  Container,
  CustomThemeProvider,
  ExternalLinkIcon,
  ModalHeader,
  QueryClient,
  QueryClientProvider,
  Spacer,
  StyledDiv,
  Text,
  darkTheme,
  iconSize,
  lightTheme,
  queryOptions,
  radius,
  useConnectionManager,
  useConnectionManagerCtx,
  useCustomTheme,
  useMutation,
  useQuery,
  useQueryClient
} from "./chunk-WOF5MGUW.js";
import "./chunk-QNGRS3PX.js";
import "./chunk-FTW4YWD3.js";
import {
  getNFT
} from "./chunk-4EAGZ3IG.js";
import "./chunk-2MPSQD2L.js";
import "./chunk-IRLSG7SP.js";
import {
  isWalletConnect
} from "./chunk-SSPMLFE5.js";
import "./chunk-KEK33COQ.js";
import "./chunk-RMLEFI72.js";
import "./chunk-6GYOX6XP.js";
import "./chunk-6XPCJUIC.js";
import "./chunk-QAWZVNN3.js";
import {
  getInjectedProvider
} from "./chunk-ZYDKTAYY.js";
import {
  isSmartWallet
} from "./chunk-UXTGY3YG.js";
import "./chunk-XBNOB4YB.js";
import {
  isInAppWallet
} from "./chunk-YHCISIHM.js";
import "./chunk-3RUNIGMR.js";
import "./chunk-PLJ2UEK7.js";
import "./chunk-FSUHYENI.js";
import "./chunk-SPYT4SSF.js";
import "./chunk-F4XDPYWB.js";
import "./chunk-L42AQSN6.js";
import "./chunk-BX6ZGBRM.js";
import "./chunk-FTGVVEWF.js";
import "./chunk-PKPPFIQW.js";
import "./chunk-E2DOQKS2.js";
import {
  webLocalStorage
} from "./chunk-57DFWRZ3.js";
import "./chunk-VWNB63MK.js";
import "./chunk-7ZEMYE2R.js";
import "./chunk-BQBBWD34.js";
import "./chunk-3MCYWU5O.js";
import "./chunk-5R32MHFT.js";
import "./chunk-67YIWUOQ.js";
import "./chunk-ARW6RUHX.js";
import "./chunk-2VXHZA4N.js";
import "./chunk-GUT7DEOA.js";
import "./chunk-G4K3WLFH.js";
import "./chunk-OB3T522R.js";
import "./chunk-IZQD6UD7.js";
import "./chunk-X54FPRZI.js";
import "./chunk-7XC4GPHZ.js";
import "./chunk-5E5FQUOC.js";
import "./chunk-M7XADWCR.js";
import "./chunk-UX72VVBB.js";
import "./chunk-M7UJHDZW.js";
import "./chunk-GJBZJ4UL.js";
import {
  isCoinbaseSDKWallet
} from "./chunk-YHAJC2I7.js";
import "./chunk-P4YNF73V.js";
import "./chunk-KE6XTC6J.js";
import "./chunk-LZH3KM55.js";
import "./chunk-ID6VDAA3.js";
import "./chunk-RIKVLZUS.js";
import "./chunk-SYURM43K.js";
import "./chunk-ZB7K7FRF.js";
import {
  getBuyWithCryptoHistory,
  getContractEvents,
  isBaseTransactionOptions,
  simulateTransaction,
  watchContractEvents
} from "./chunk-VGFFALND.js";
import {
  sendBatchTransaction
} from "./chunk-ONHLR6UH.js";
import {
  estimateGasCost,
  getPayBuyWithFiatHistoryEndpoint
} from "./chunk-TJGHGGIC.js";
import {
  sendAndConfirmTransaction
} from "./chunk-25UT6ZS2.js";
import {
  eth_blockNumber,
  waitForReceipt,
  watchBlockNumber
} from "./chunk-OTOBMETN.js";
import "./chunk-P67K46QJ.js";
import "./chunk-HO6P54JG.js";
import "./chunk-YAPA4KI3.js";
import {
  once,
  prepareContractCall
} from "./chunk-OVEQXALL.js";
import {
  NATIVE_TOKEN_ADDRESS,
  isNativeTokenAddress
} from "./chunk-F2NDM2JU.js";
import "./chunk-HIZG7GSI.js";
import {
  isObjectWithKeys
} from "./chunk-WWY7S4YD.js";
import "./chunk-OULA2JUL.js";
import {
  sendTransaction
} from "./chunk-5CJUBOTY.js";
import "./chunk-DVPCWDY6.js";
import "./chunk-OSZAYZBM.js";
import {
  estimateGas
} from "./chunk-S2KMC4ZU.js";
import {
  eth_getBlockByNumber
} from "./chunk-RQ5H3BEW.js";
import {
  resolvePromisedValue
} from "./chunk-2FH4XCFL.js";
import "./chunk-CMXLKATA.js";
import "./chunk-VYA3UASK.js";
import "./chunk-PZWOPBWI.js";
import {
  toUnits
} from "./chunk-HAADYJEF.js";
import "./chunk-WAYCTEWF.js";
import "./chunk-SY6M73X4.js";
import {
  encode
} from "./chunk-GEF6DW5R.js";
import {
  getContract
} from "./chunk-V4R6W4TB.js";
import "./chunk-FPO5TL63.js";
import {
  readContract
} from "./chunk-BF6IWIHR.js";
import "./chunk-4OMQ45VH.js";
import {
  getRpcClient
} from "./chunk-KFTJWVLQ.js";
import {
  stringify
} from "./chunk-7IZG4EP5.js";
import "./chunk-3UYCMIWJ.js";
import {
  getAddress
} from "./chunk-UV67MG5D.js";
import "./chunk-JMJMW6FX.js";
import "./chunk-CY3CMUVN.js";
import {
  numberToHex,
  uint8ArrayToHex
} from "./chunk-BNK74YTA.js";
import "./chunk-GDDTQ4UI.js";
import "./chunk-IAQW7B5J.js";
import "./chunk-Z2F5LG57.js";
import "./chunk-L46BJXKD.js";
import {
  sha256
} from "./chunk-EWAXOTDC.js";
import "./chunk-TEQAYQEZ.js";
import "./chunk-ISKIRMJU.js";
import "./chunk-TT4DF327.js";
import "./chunk-JCHRT6I2.js";
import {
  cacheChains
} from "./chunk-SYYDPSNZ.js";
import "./chunk-MHFR2GDE.js";
import {
  getClientFetch
} from "./chunk-SUMWJFR6.js";
import "./chunk-EZ4JTQAA.js";
import "./chunk-SHWHM7JY.js";
import "./chunk-7JMZ4B64.js";
import "./chunk-EQCCHGRT.js";
import "./chunk-BS5EKVYB.js";
import "./chunk-IYNIHSXD.js";
import {
  require_jsx_runtime
} from "./chunk-6PF5PHNV.js";
import {
  require_react
} from "./chunk-7SNDHR3H.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/Modal/ConnectEmbed.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/core/hooks/wallets/useIsAutoConnecting.js
var import_react = __toESM(require_react(), 1);
function useIsAutoConnecting() {
  const manager = useConnectionManagerCtx("useIsAutoConnecting");
  const store = manager.isAutoConnecting;
  return (0, import_react.useSyncExternalStore)(store.subscribe, store.getValue, store.getValue);
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/Modal/ConnectEmbed.js
function ConnectEmbed(props) {
  var _a, _b;
  const activeWallet = useActiveWallet();
  const activeAccount = useActiveAccount();
  const siweAuth = useSiweAuth(activeWallet, activeAccount, props.auth);
  const show = !activeAccount || siweAuth.requiresAuth && !siweAuth.isLoggedIn;
  if (props.chains) {
    cacheChains(props.chains);
  }
  if (props.chain) {
    cacheChains([props.chain]);
  }
  const wallets = (0, import_react2.useMemo)(() => props.wallets || getDefaultWallets({
    appMetadata: props.appMetadata,
    chains: props.chains
  }), [props.wallets, props.appMetadata, props.chains]);
  const localeId = props.locale || "en_US";
  const localeQuery = useConnectLocale(localeId);
  usePreloadWalletProviders({
    wallets,
    client: props.client
  });
  const modalSize = (0, import_react2.useMemo)(() => {
    return !canFitWideModal() || wallets.length === 1 ? "compact" : props.modalSize || "compact";
  }, [wallets.length, props.modalSize]);
  const meta = (0, import_react2.useMemo)(() => {
    return {
      privacyPolicyUrl: props.privacyPolicyUrl,
      showThirdwebBranding: props.showThirdwebBranding !== false,
      termsOfServiceUrl: props.termsOfServiceUrl,
      title: void 0,
      titleIconUrl: void 0
    };
  }, [
    props.privacyPolicyUrl,
    props.showThirdwebBranding,
    props.termsOfServiceUrl
  ]);
  const autoConnectComp = props.autoConnect !== false && (0, import_jsx_runtime.jsx)(AutoConnect, { appMetadata: props.appMetadata, client: props.client, wallets, accountAbstraction: props.accountAbstraction, timeout: typeof props.autoConnect === "boolean" ? void 0 : (_a = props.autoConnect) == null ? void 0 : _a.timeout, onConnect: props.onConnect });
  if (show) {
    if (!localeQuery.data) {
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [autoConnectComp, (0, import_jsx_runtime.jsx)(CustomThemeProvider, { theme: props.theme, children: (0, import_jsx_runtime.jsx)(EmbedContainer, { modalSize, children: (0, import_jsx_runtime.jsx)(LoadingScreen, {}) }) })] });
    }
    return (0, import_jsx_runtime.jsxs)(WalletUIStatesProvider, { theme: props.theme, isOpen: true, children: [(0, import_jsx_runtime.jsx)(ConnectEmbedContent, { auth: props.auth, accountAbstraction: props.accountAbstraction, chain: props.chain || ((_b = props.accountAbstraction) == null ? void 0 : _b.chain), chains: props.chains, client: props.client, connectLocale: localeQuery.data, size: modalSize, meta, isEmbed: true, localeId: props.locale || "en_US", onConnect: props.onConnect, recommendedWallets: props.recommendedWallets, showAllWallets: props.showAllWallets, walletConnect: props.walletConnect, wallets, className: props.className, modalSize, style: props.style, welcomeScreen: props.welcomeScreen }), autoConnectComp] });
  }
  return (0, import_jsx_runtime.jsx)("div", { children: autoConnectComp });
}
var ConnectEmbedContent = (props) => {
  const screenSetup = useSetupScreen({
    size: props.size,
    welcomeScreen: void 0,
    wallets: props.wallets
  });
  const { setScreen, initialScreen, screen } = screenSetup;
  const activeWallet = useActiveWallet();
  const activeAccount = useActiveAccount();
  const siweAuth = useSiweAuth(activeWallet, activeAccount, props.auth);
  const isAutoConnecting = useIsAutoConnecting();
  let content = null;
  (0, import_react2.useEffect)(() => {
    if (siweAuth.requiresAuth && !siweAuth.isLoggedIn && activeAccount && screen === initialScreen) {
      setScreen(reservedScreens.signIn);
    }
  }, [siweAuth, setScreen, activeAccount, screen, initialScreen]);
  const modalSize = !canFitWideModal() ? "compact" : props.modalSize || "compact";
  if (isAutoConnecting) {
    content = (0, import_jsx_runtime.jsx)(LoadingScreen, {});
  } else {
    content = (0, import_jsx_runtime.jsx)(ConnectModalContent, { shouldSetActive: true, screenSetup, isOpen: true, onClose: () => {
      setScreen(initialScreen);
    }, setModalVisibility: () => {
    }, accountAbstraction: props.accountAbstraction, auth: props.auth, chain: props.chain, chains: props.chains, client: props.client, connectLocale: props.connectLocale, meta: props.meta, size: props.size, welcomeScreen: props.welcomeScreen, isEmbed: props.isEmbed, onConnect: props.onConnect, recommendedWallets: props.recommendedWallets, showAllWallets: props.showAllWallets, walletConnect: props.walletConnect, wallets: props.wallets, modalHeader: void 0, walletIdsToHide: void 0 });
  }
  return (0, import_jsx_runtime.jsx)(EmbedContainer, { modalSize, className: props.className, style: props.style, children: modalSize === "wide" ? content : (0, import_jsx_runtime.jsxs)(DynamicHeight, { children: [" ", content, " "] }) });
};
var EmbedContainer = StyledDiv((props) => {
  const { modalSize } = props;
  const theme = useCustomTheme();
  return {
    color: theme.colors.primaryText,
    background: theme.colors.modalBg,
    height: modalSize === "compact" ? "auto" : wideModalMaxHeight,
    width: modalSize === "compact" ? modalMaxWidthCompact : modalMaxWidthWide,
    boxSizing: "border-box",
    position: "relative",
    lineHeight: "normal",
    borderRadius: radius.xl,
    border: `1px solid ${theme.colors.borderColor}`,
    overflow: "hidden",
    fontFamily: theme.fontFamily,
    "& *::selection": {
      backgroundColor: theme.colors.primaryText,
      color: theme.colors.modalBg
    },
    "& *": {
      boxSizing: "border-box"
    }
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/TransactionButton/index.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/transaction-button-utils.js
var useTransactionButtonMutation = (props, sendTransactionFn) => {
  const { transaction, onTransactionSent, onTransactionConfirmed, onError, onClick } = props;
  return useMutation({
    mutationFn: async () => {
      if (onClick) {
        onClick();
      }
      try {
        const resolvedTx = await transaction();
        const result = await sendTransactionFn(resolvedTx);
        if (onTransactionSent) {
          onTransactionSent(result);
        }
        if (onTransactionConfirmed) {
          const receipt = await waitForReceipt(result);
          if (receipt.status === "reverted") {
            throw new Error(`Execution reverted: ${stringify(receipt, null, 2)}`);
          }
          onTransactionConfirmed(receipt);
        }
      } catch (error) {
        if (onError) {
          onError(error);
        }
      } finally {
      }
    }
  });
};

// node_modules/thirdweb/dist/esm/react/web/hooks/transaction/useSendTransaction.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/useSendTransaction.js
function useSendTransactionCore(args) {
  const { showPayModal, gasless, wallet, switchChain } = args;
  let _account = wallet == null ? void 0 : wallet.getAccount();
  return useMutation({
    mutationFn: async (tx) => {
      var _a;
      if (wallet && tx.chain.id !== ((_a = wallet.getChain()) == null ? void 0 : _a.id)) {
        await switchChain(tx.chain);
        _account = wallet.getAccount();
      }
      const account = _account;
      if (!account) {
        throw new Error("No active account");
      }
      if (!showPayModal) {
        return sendTransaction({
          transaction: tx,
          account,
          gasless
        });
      }
      return new Promise((resolve, reject) => {
        const sendTx = async () => {
          try {
            const res = await sendTransaction({
              transaction: tx,
              account,
              gasless
            });
            resolve(res);
          } catch (e) {
            reject(e);
          }
        };
        (async () => {
          try {
            const [_nativeValue, _erc20Value] = await Promise.all([
              resolvePromisedValue(tx.value),
              resolvePromisedValue(tx.erc20Value)
            ]);
            const nativeValue = _nativeValue || 0n;
            const erc20Value = (_erc20Value == null ? void 0 : _erc20Value.amountWei) || 0n;
            if (nativeValue > 0n || erc20Value > 0n) {
              showPayModal({
                tx,
                sendTx,
                rejectTx: reject,
                resolveTx: resolve
              });
            } else {
              sendTx();
            }
          } catch (e) {
            console.error("Failed to estimate cost", e);
            sendTx();
          }
        })();
      });
    }
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/TransactionButton/TransactionModal.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/TransactionButton/ExecutingScreen.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
function ExecutingTxScreen(props) {
  var _a;
  const sendTxCore = useSendTransaction({
    payModal: false
  });
  const [txHash, setTxHash] = (0, import_react3.useState)();
  const chainExplorers = useChainExplorers(props.tx.chain);
  const [status, setStatus] = (0, import_react3.useState)("loading");
  const sendTx = (0, import_react3.useCallback)(async () => {
    setStatus("loading");
    try {
      const txData = await sendTxCore.mutateAsync(props.tx);
      setTxHash(txData.transactionHash);
      props.onTxSent(txData);
      setStatus("sent");
    } catch (e) {
      console.error(e);
      setStatus("failed");
    }
  }, [sendTxCore, props.tx, props.onTxSent]);
  const done = (0, import_react3.useRef)(false);
  (0, import_react3.useEffect)(() => {
    if (done.current) {
      return;
    }
    done.current = true;
    sendTx();
  }, [sendTx]);
  return (0, import_jsx_runtime2.jsxs)(Container, { p: "lg", children: [(0, import_jsx_runtime2.jsx)(ModalHeader, { title: "Transaction", onBack: props.onBack }), (0, import_jsx_runtime2.jsx)(Spacer, { y: "xxl" }), (0, import_jsx_runtime2.jsx)(Spacer, { y: "xxl" }), (0, import_jsx_runtime2.jsxs)(Container, { flex: "row", center: "x", children: [status === "loading" && (0, import_jsx_runtime2.jsx)(Spinner, { size: "xxl", color: "accentText" }), status === "failed" && (0, import_jsx_runtime2.jsx)(AccentFailIcon, { size: iconSize["3xl"] }), status === "sent" && (0, import_jsx_runtime2.jsx)(Container, { color: "success", flex: "row", center: "both", children: (0, import_jsx_runtime2.jsx)(CheckCircledIcon, { width: iconSize["3xl"], height: iconSize["3xl"] }) })] }), (0, import_jsx_runtime2.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime2.jsxs)(Text, { color: "primaryText", center: true, size: "lg", children: [status === "loading" && "Sending transaction", status === "failed" && "Transaction failed", status === "sent" && "Transaction sent"] }), (0, import_jsx_runtime2.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime2.jsx)(Text, { color: "danger", center: true, size: "sm", children: status === "failed" && sendTxCore.error ? sendTxCore.error.message : "" }), (0, import_jsx_runtime2.jsx)(Spacer, { y: "xxl" }), (0, import_jsx_runtime2.jsx)(Spacer, { y: "xxl" }), status === "failed" && (0, import_jsx_runtime2.jsx)(Button, { variant: "accent", fullWidth: true, onClick: sendTx, children: "Try Again" }), status === "sent" && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Button, { variant: "accent", fullWidth: true, onClick: props.closeModal, children: "Done" }), txHash && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime2.jsxs)(ButtonLink, { fullWidth: true, variant: "outline", href: `${(_a = chainExplorers.explorers[0]) == null ? void 0 : _a.url}/tx/${txHash}`, target: "_blank", as: "a", gap: "xs", style: {
    textDecoration: "none",
    color: "inherit"
  }, children: ["View on Explorer", " ", (0, import_jsx_runtime2.jsx)(ExternalLinkIcon, { width: iconSize.sm, height: iconSize.sm })] })] })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/TransactionButton/TransactionModal.js
function TransactionModal(props) {
  return (0, import_jsx_runtime3.jsx)(CustomThemeProvider, { theme: props.theme, children: (0, import_jsx_runtime3.jsx)(Modal, { open: true, size: "compact", setOpen: (_open) => {
    if (!_open) {
      props.onClose();
    }
  }, children: (0, import_jsx_runtime3.jsx)(TransactionModalContent, { ...props }) }) });
}
function TransactionModalContent(props) {
  const localeQuery = useConnectLocale(props.localeId);
  const [screen, setScreen] = (0, import_react4.useState)("buy");
  if (!localeQuery.data) {
    return (0, import_jsx_runtime3.jsx)(LoadingScreen, {});
  }
  if (screen === "execute-tx") {
    return (0, import_jsx_runtime3.jsx)(ExecutingTxScreen, { tx: props.tx, closeModal: props.onClose, onTxSent: props.onTxSent });
  }
  return (0, import_jsx_runtime3.jsx)(LazyBuyScreen, { title: props.title, isEmbed: false, client: props.client, onBack: props.onBack, supportedTokens: props.supportedTokens, connectLocale: localeQuery.data, theme: typeof props.theme === "string" ? props.theme : props.theme.type, payOptions: props.payOptions, onDone: () => {
    setScreen("execute-tx");
  }, connectOptions: void 0 });
}

// node_modules/thirdweb/dist/esm/react/web/hooks/transaction/useSendTransaction.js
function useSendTransaction(config = {}) {
  const switchChain = useSwitchActiveWalletChain();
  const wallet = useActiveWallet();
  const setRootEl = (0, import_react5.useContext)(SetRootElementContext);
  const payModal = config.payModal;
  let payModalEnabled = true;
  if (payModal === false || config.gasless) {
    payModalEnabled = false;
  }
  const showPayModal = (data) => {
    var _a;
    if (payModal === false)
      return;
    setRootEl((0, import_jsx_runtime4.jsx)(TransactionModal, { title: ((_a = payModal == null ? void 0 : payModal.metadata) == null ? void 0 : _a.name) || "Transaction", tx: data.tx, onComplete: data.sendTx, onClose: () => {
      setRootEl(null);
      data.rejectTx(new Error("User rejected transaction by closing modal"));
    }, onTxSent: data.resolveTx, client: data.tx.client, localeId: (payModal == null ? void 0 : payModal.locale) || "en_US", supportedTokens: payModal == null ? void 0 : payModal.supportedTokens, theme: (payModal == null ? void 0 : payModal.theme) || "dark", payOptions: {
      buyWithCrypto: payModal == null ? void 0 : payModal.buyWithCrypto,
      buyWithFiat: payModal == null ? void 0 : payModal.buyWithFiat,
      purchaseData: payModal == null ? void 0 : payModal.purchaseData,
      mode: "transaction",
      transaction: data.tx,
      metadata: payModal == null ? void 0 : payModal.metadata
    } }));
  };
  return useSendTransactionCore({
    showPayModal: !payModalEnabled || payModal === false ? void 0 : showPayModal,
    gasless: config.gasless,
    switchChain,
    wallet
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/TransactionButton/index.js
function TransactionButton(props) {
  const { children, transaction, onTransactionSent, onTransactionConfirmed, onError, onClick, gasless, payModal, disabled, unstyled, ...buttonProps } = props;
  const account = useActiveAccount();
  const sendTransaction2 = useSendTransaction({ gasless, payModal });
  const { mutate: handleClick, isPending } = useTransactionButtonMutation(props, sendTransaction2.mutateAsync);
  return (0, import_jsx_runtime5.jsx)(CustomThemeProvider, { theme: props.theme, children: (0, import_jsx_runtime5.jsxs)(Button, { gap: "xs", disabled: !account || disabled || isPending, variant: "primary", unstyled, "data-is-loading": isPending, onClick: () => handleClick(), ...buttonProps, style: !unstyled ? {
    opacity: !account || disabled ? 0.5 : 1,
    minWidth: "150px",
    position: "relative",
    ...buttonProps.style
  } : {
    position: "relative",
    ...buttonProps.style
  }, children: [(0, import_jsx_runtime5.jsx)("span", { style: { visibility: isPending ? "hidden" : "visible" }, children }), isPending && (0, import_jsx_runtime5.jsx)("div", { style: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    height: "100%",
    top: 0,
    bottom: 0,
    margin: "auto"
  }, children: (0, import_jsx_runtime5.jsx)(Spinner, { size: "md", color: "primaryButtonText" }) })] }) });
}

// node_modules/thirdweb/dist/esm/react/web/providers/thirdweb-provider.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/core/providers/thirdweb-provider.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
function ThirdwebProviderCore(props) {
  const [el, setEl] = (0, import_react6.useState)(null);
  const [queryClient] = (0, import_react6.useState)(() => new QueryClient({
    defaultOptions: {
      mutations: {
        onSettled: (data, _error, variables) => {
          if (isBaseTransactionOptions(variables)) {
            if (isObjectWithKeys(data, ["transactionHash"]) && isObjectWithKeys(variables, ["client", "chain"])) {
              waitForReceipt({
                transactionHash: data.transactionHash,
                // We know it exists from the if
                client: variables.client,
                chain: variables.chain
              }).catch((e) => {
                console.error("[Transaction Error]", e);
              }).then(() => {
                var _a, _b, _c;
                return Promise.all([
                  queryClient.invalidateQueries({
                    queryKey: (
                      // invalidate any readContract queries for this chainId:contractAddress
                      [
                        "readContract",
                        (_a = variables.__contract) == null ? void 0 : _a.chain.id,
                        (_b = variables.__contract) == null ? void 0 : _b.address
                      ]
                    )
                  }),
                  invalidateWalletBalance(queryClient, (_c = variables.__contract) == null ? void 0 : _c.chain.id)
                ]);
              });
            }
          }
        }
      },
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1e3
      }
    }
  }));
  return (0, import_jsx_runtime6.jsx)(ConnectionManagerCtx.Provider, { value: props.manager, children: (0, import_jsx_runtime6.jsxs)(QueryClientProvider, { client: queryClient, children: [(0, import_jsx_runtime6.jsx)(SetRootElementContext.Provider, { value: setEl, children: props.children }), el] }) });
}

// node_modules/thirdweb/dist/esm/react/web/providers/thirdweb-provider.js
function ThirdwebProvider(props) {
  const connectionManager = (0, import_react7.useMemo)(() => props.connectionManager || createConnectionManager(webLocalStorage), [props.connectionManager]);
  return (0, import_jsx_runtime7.jsx)(ThirdwebProviderCore, { manager: connectionManager, children: props.children });
}

// node_modules/thirdweb/dist/esm/wallets/eip5792/get-capabilities.js
async function getCapabilities({ wallet }) {
  const account = wallet.getAccount();
  if (!account) {
    return {
      message: `Can't get capabilities, no account connected for wallet: ${wallet.id}`
    };
  }
  if (isSmartWallet(wallet)) {
    const { smartWalletGetCapabilities } = await import("./smart-wallet-capabilities-HDF56HY7.js");
    return smartWalletGetCapabilities({ wallet });
  }
  if (isInAppWallet(wallet)) {
    const { inAppWalletGetCapabilities } = await import("./in-app-wallet-capabilities-HQBAILHL.js");
    return inAppWalletGetCapabilities({ wallet });
  }
  if (isCoinbaseSDKWallet(wallet)) {
    const { coinbaseSDKWalletGetCapabilities } = await import("./coinbaseWebSDK-FSTFG62C.js");
    return coinbaseSDKWalletGetCapabilities({ wallet });
  }
  if (isWalletConnect(wallet)) {
    return {
      message: "getCapabilities is not yet supported with Wallet Connect"
    };
  }
  const provider = getInjectedProvider(wallet.id);
  try {
    return await provider.request({
      method: "wallet_getCapabilities",
      params: [account.address]
    });
  } catch (error) {
    if (/unsupport|not support|not available/i.test(error.message)) {
      return {
        message: `${wallet.id} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`
      };
    }
    throw error;
  }
}

// node_modules/thirdweb/dist/esm/react/core/hooks/wallets/useCapabilities.js
function useCapabilities(options) {
  var _a;
  const wallet = useActiveWallet();
  return useQuery({
    queryKey: [
      "getCapabilities",
      ((_a = wallet == null ? void 0 : wallet.getChain()) == null ? void 0 : _a.id) || -1,
      wallet == null ? void 0 : wallet.id
    ],
    queryFn: async () => {
      if (!wallet) {
        return {
          message: "Can't get capabilities, no wallet connected"
        };
      }
      return getCapabilities({ wallet });
    },
    retry: false,
    ...options == null ? void 0 : options.queryOptions
  });
}

// node_modules/thirdweb/dist/esm/wallets/eip5792/send-calls.js
async function sendCalls(options) {
  const { wallet, calls, capabilities, version = "1.0", chain = wallet.getChain() } = options;
  if (!chain) {
    throw new Error(`Cannot send calls, no active chain found for wallet: ${wallet.id}`);
  }
  const account = wallet.getAccount();
  if (!account) {
    throw new Error(`Cannot send calls, no account connected for wallet: ${wallet.id}`);
  }
  if (isSmartWallet(wallet) || isInAppWallet(wallet)) {
    const { inAppWalletSendCalls } = await import("./in-app-wallet-calls-YVTC5BBO.js");
    return inAppWalletSendCalls({ account, calls });
  }
  const preparedCalls = await Promise.all(calls.map(async (call) => {
    const { to, value } = call;
    if (to === void 0 && call.data === void 0) {
      throw new Error("Cannot send call, `to` or `data` must be provided.");
    }
    const [_to, _data, _value] = await Promise.all([
      resolvePromisedValue(to),
      encode(call),
      resolvePromisedValue(value)
    ]);
    return {
      to: _to,
      data: _data,
      value: typeof _value === "bigint" || typeof _value === "number" ? numberToHex(_value) : void 0
    };
  }));
  const injectedWalletCallParams = [
    {
      from: getAddress(account.address),
      calls: preparedCalls,
      capabilities,
      version,
      chainId: numberToHex(chain.id)
    }
  ];
  if (isCoinbaseSDKWallet(wallet)) {
    const { coinbaseSDKWalletSendCalls } = await import("./coinbaseWebSDK-FSTFG62C.js");
    return coinbaseSDKWalletSendCalls({
      wallet,
      params: injectedWalletCallParams
    });
  }
  if (isWalletConnect(wallet)) {
    throw new Error("sendCalls is not yet supported for Wallet Connect");
  }
  const provider = getInjectedProvider(wallet.id);
  try {
    return await provider.request({
      method: "wallet_sendCalls",
      params: injectedWalletCallParams
      // The viem type definition is slightly different
    });
  } catch (error) {
    if (/unsupport|not support/i.test(error.message)) {
      throw new Error(`${wallet.id} does not support wallet_sendCalls, reach out to them directly to request EIP-5792 support.`);
    }
    throw error;
  }
}

// node_modules/thirdweb/dist/esm/wallets/eip5792/get-calls-status.js
async function getCallsStatus({ wallet, client, bundleId }) {
  const account = wallet.getAccount();
  if (!account) {
    throw new Error(`Failed to get call status, no account found for wallet ${wallet.id}`);
  }
  if (isSmartWallet(wallet) || isInAppWallet(wallet)) {
    const { inAppWalletGetCallsStatus } = await import("./in-app-wallet-calls-YVTC5BBO.js");
    return inAppWalletGetCallsStatus({ wallet, client, bundleId });
  }
  if (isCoinbaseSDKWallet(wallet)) {
    const { coinbaseSDKWalletGetCallsStatus } = await import("./coinbaseWebSDK-FSTFG62C.js");
    return coinbaseSDKWalletGetCallsStatus({ wallet, bundleId });
  }
  if (isWalletConnect(wallet)) {
    throw new Error("getCallsStatus is not yet supported for Wallet Connect");
  }
  const provider = getInjectedProvider(wallet.id);
  try {
    return await provider.request({
      method: "wallet_getCallsStatus",
      params: [bundleId]
    });
  } catch (error) {
    if (/unsupport|not support/i.test(error.message)) {
      throw new Error(`${wallet.id} does not support wallet_getCallsStatus, reach out to them directly to request EIP-5792 support.`);
    }
    throw error;
  }
}

// node_modules/thirdweb/dist/esm/wallets/eip5792/wait-for-bundle.js
var DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;
var map = /* @__PURE__ */ new Map();
function waitForBundle(options) {
  const { bundleId, chain, wallet, client } = options;
  const chainId = chain.id;
  const key = `${chainId}:calls_${bundleId}`;
  const maxBlocksWaitTime = options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;
  if (map.has(key)) {
    return map.get(key);
  }
  const promise = new Promise((resolve, reject) => {
    let blocksWaited = -1;
    const unwatch = watchBlockNumber({
      client,
      chain,
      onNewBlockNumber: async () => {
        blocksWaited++;
        if (blocksWaited >= maxBlocksWaitTime) {
          unwatch();
          reject(new Error(`Bundle not confirmed after ${maxBlocksWaitTime} blocks`));
          return;
        }
        try {
          const result = await getCallsStatus({
            wallet,
            client,
            bundleId
          });
          if (result.status === "CONFIRMED") {
            unwatch();
            resolve(result);
          }
        } catch {
        }
      }
    });
  }).finally(() => {
    map.delete(key);
  });
  map.set(key, promise);
  return promise;
}

// node_modules/thirdweb/dist/esm/react/core/hooks/wallets/useSendCalls.js
function useSendCalls({ client, waitForResult = true }) {
  const activeWallet = useActiveWallet();
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (options) => {
      const { wallet = activeWallet } = options;
      const chain = wallet == null ? void 0 : wallet.getChain();
      if (!wallet || !chain) {
        throw new Error("Failed to send transactions, no connected wallet found.");
      }
      const callsPromise = sendCalls({ ...options, wallet });
      if (!waitForResult) {
        return callsPromise;
      }
      const result = await waitForBundle({
        bundleId: await callsPromise,
        wallet,
        client,
        chain
      });
      return result;
    },
    onSettled: async (_result, _error, variables) => {
      var _a, _b;
      const chain = activeWallet == null ? void 0 : activeWallet.getChain();
      if (!_result || !activeWallet || !chain) {
        return;
      }
      if (typeof _result === "string") {
        await waitForBundle({
          bundleId: _result,
          wallet: activeWallet,
          client,
          chain
        }).catch((error) => {
          console.error("Failed to confirm sent bundle and invalidate queries", _result, error);
          return void 0;
        });
      }
      for (const call of variables.calls) {
        queryClient.invalidateQueries({
          queryKey: [
            "readContract",
            (_a = call.__contract) == null ? void 0 : _a.chain.id,
            (_b = call.__contract) == null ? void 0 : _b.address
          ]
        });
      }
      invalidateWalletBalance(queryClient, chain.id);
    }
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/wallets/useCallsStatus.js
function useCallsStatus(options) {
  var _a;
  const { client, bundleId } = options;
  const wallet = useActiveWallet();
  return useQuery({
    queryKey: [
      "getCapabilities",
      ((_a = wallet == null ? void 0 : wallet.getChain()) == null ? void 0 : _a.id) || -1,
      wallet == null ? void 0 : wallet.id
    ],
    queryFn: async () => {
      if (!wallet) {
        throw new Error("Failed to get calls status, no wallet connected");
      }
      return getCallsStatus({ wallet, client, bundleId });
    },
    retry: false,
    enabled: !!bundleId && wallet !== void 0,
    ...options.queryOptions
  });
}

// node_modules/thirdweb/dist/esm/utils/function-id.js
var functionIdCache = /* @__PURE__ */ new WeakMap();
function getFunctionId(fn) {
  if (functionIdCache.has(fn)) {
    return functionIdCache.get(fn);
  }
  const id = uint8ArrayToHex(sha256(fn.toString()));
  functionIdCache.set(fn, id);
  return id;
}

// node_modules/thirdweb/dist/esm/react/core/hooks/contract/useReadContract.js
function useReadContract(extensionOrOptions, options) {
  if (typeof extensionOrOptions === "function") {
    if (!options) {
      throw new Error(`Missing second argument for "useReadContract(<extension>, <options>)" hook.`);
    }
    const { queryOptions: queryOptions2, contract, ...params } = options;
    const query = queryOptions({
      queryKey: [
        "readContract",
        contract.chain.id,
        contract.address,
        getFunctionId(extensionOrOptions),
        stringify(params)
      ],
      // @ts-expect-error - TODO: clean up the type issues here
      queryFn: () => extensionOrOptions({ ...params, contract }),
      ...queryOptions2
    });
    return useQuery(query);
  }
  if ("method" in extensionOrOptions) {
    const { queryOptions: queryOptions2, ...tx } = extensionOrOptions;
    const query = queryOptions({
      queryKey: [
        "readContract",
        tx.contract.chain.id,
        tx.contract.address,
        tx.method,
        stringify(tx.params)
      ],
      queryFn: () => readContract(extensionOrOptions),
      ...queryOptions2
    });
    return useQuery(query);
  }
  throw new Error(`Invalid "useReadContract" options. Expected either a read extension or a transaction object.`);
}

// node_modules/thirdweb/dist/esm/react/core/hooks/contract/useContractEvents.js
var import_react8 = __toESM(require_react(), 1);
function useContractEvents(options) {
  const { contract, events, blockRange = 2e3, enabled = true, watch = true } = options;
  const latestBlockNumber = (0, import_react8.useRef)();
  const queryClient = useQueryClient();
  const eventsKey = (0, import_react8.useMemo)(() => (events == null ? void 0 : events.reduce((acc, curr) => {
    return `${acc}${curr.hash}_`;
  }, "")) || "__all__", [events]);
  const queryKey = (0, import_react8.useMemo)(() => [contract.chain.id, contract.address, "logs", eventsKey], [contract.address, contract.chain, eventsKey]);
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      const rpcRequest = getRpcClient(contract);
      const currentBlockNumber = await eth_blockNumber(rpcRequest);
      latestBlockNumber.current = currentBlockNumber;
      const initialEvents = await getContractEvents({
        contract,
        events,
        fromBlock: currentBlockNumber - BigInt(blockRange)
      });
      return initialEvents;
    },
    enabled
  });
  (0, import_react8.useEffect)(() => {
    if (!enabled || !watch) {
      return;
    }
    return watchContractEvents({
      contract,
      onEvents: (newEvents) => {
        if (newEvents.length > 0 && newEvents[0]) {
          latestBlockNumber.current = newEvents[0].blockNumber;
        }
        queryClient.setQueryData(queryKey, (oldEvents = []) => [
          ...oldEvents,
          ...newEvents
        ]);
      },
      events,
      latestBlockNumber: latestBlockNumber.current
    });
  }, [contract, enabled, events, queryClient, queryKey, watch]);
  return query;
}

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/useSimulateTransaction.js
function useSimulateTransaction() {
  return useMutation({
    mutationFn: (options) => simulateTransaction(options)
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/useSendBatchTransaction.js
function useSendBatchTransaction() {
  const account = useActiveAccount();
  return useMutation({
    mutationFn: async (transactions) => {
      if (!account) {
        throw new Error("No active account");
      }
      return await sendBatchTransaction({
        transactions,
        account
      });
    }
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/useSendAndConfirmTransaction.js
function useSendAndConfirmTransaction() {
  const account = useActiveAccount();
  return useMutation({
    mutationFn: async (transaction) => {
      if (!account) {
        throw new Error("No active account");
      }
      return await sendAndConfirmTransaction({
        transaction,
        account
      });
    }
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/useEstimateGas.js
function useEstimateGas() {
  const account = useActiveAccount();
  return useMutation({
    mutationFn: (transaction) => estimateGas({ transaction, account })
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/useEstimateGasCost.js
function useEstimateGasCost() {
  const account = useActiveAccount();
  return useMutation({
    mutationFn: (transaction) => estimateGasCost({ transaction, account })
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/rpc/useBlockNumber.js
var import_react9 = __toESM(require_react(), 1);
function useBlockNumber(options) {
  const { client, chain, enabled = true, watch = true } = options;
  const queryClient = useQueryClient();
  const queryKey = (0, import_react9.useMemo)(() => [chain.id, "blockNumber"], [chain]);
  const query = useQuery({
    // TODO: technically client should be part of the queryKey here...
    queryKey,
    queryFn: async () => {
      const rpcRequest = getRpcClient({ client, chain });
      return await eth_blockNumber(rpcRequest);
    },
    enabled
  });
  (0, import_react9.useEffect)(() => {
    if (!enabled || !watch) {
      return;
    }
    return watchBlockNumber({
      client,
      chain,
      onNewBlockNumber: (newBlockNumber) => {
        queryClient.setQueryData(queryKey, newBlockNumber);
      }
    });
  }, [client, chain, enabled, queryClient, queryKey, watch]);
  return query.data;
}

// node_modules/thirdweb/dist/esm/react/core/utils/createQuery.js
var CONTRACT_QUERY_CACHE = /* @__PURE__ */ new WeakMap();
function createContractQuery(readCall) {
  if (CONTRACT_QUERY_CACHE.has(readCall)) {
    return CONTRACT_QUERY_CACHE.get(readCall);
  }
  function useRead(options) {
    const { contract, queryOptions: queryOptions2, ...params } = options;
    return useQuery({
      queryKey: [
        "readContract",
        contract.chain.id,
        contract.address,
        getFunctionId(readCall),
        stringify(params)
      ],
      queryFn: () => readCall(options),
      ...queryOptions2
    });
  }
  CONTRACT_QUERY_CACHE.set(readCall, useRead);
  return useRead;
}

// node_modules/thirdweb/dist/esm/react/core/hooks/others/useInvalidateQueries.js
function useInvalidateContractQuery() {
  const queryClient = useQueryClient();
  return ({ chainId, contractAddress }) => {
    queryClient.invalidateQueries({
      queryKey: ["readContract", chainId, contractAddress]
    });
  };
}

// node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithCryptoHistory.js
function useBuyWithCryptoHistory(params, queryParams) {
  return useQuery({
    ...queryParams,
    queryKey: ["getBuyWithCryptoHistory", params],
    queryFn: () => {
      if (!params) {
        throw new Error("Swap params are required");
      }
      return getBuyWithCryptoHistory(params);
    },
    enabled: !!params
  });
}

// node_modules/thirdweb/dist/esm/pay/buyWithFiat/getHistory.js
async function getBuyWithFiatHistory(params) {
  var _a;
  try {
    const queryParams = new URLSearchParams();
    queryParams.append("walletAddress", params.walletAddress);
    queryParams.append("start", params.start.toString());
    queryParams.append("count", params.count.toString());
    const queryString = queryParams.toString();
    const url = `${getPayBuyWithFiatHistoryEndpoint()}?${queryString}`;
    const response = await getClientFetch(params.client)(url);
    if (!response.ok) {
      (_a = response.body) == null ? void 0 : _a.cancel();
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    return data;
  } catch (error) {
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithFiatHistory.js
function useBuyWithFiatHistory(params, queryParams) {
  return useQuery({
    ...queryParams,
    queryKey: ["buyWithFiatHistory", params],
    queryFn: () => {
      if (!params) {
        throw new Error("params are required");
      }
      return getBuyWithFiatHistory(params);
    },
    enabled: !!params
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/pay/usePostOnrampQuote.js
function usePostOnRampQuote(params, queryOptions2) {
  return useQuery({
    ...queryOptions2,
    queryKey: ["getPostOnRampQuote", params],
    queryFn: async () => {
      if (!params) {
        throw new Error("No params provided");
      }
      return getPostOnRampQuote(params);
    },
    enabled: !!params
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/PayEmbed.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
function PayEmbed(props) {
  var _a, _b, _c, _d, _e;
  const localeQuery = useConnectLocale(props.locale || "en_US");
  const [screen, setScreen] = (0, import_react10.useState)("buy");
  const theme = props.theme || "dark";
  if ((_a = props.connectOptions) == null ? void 0 : _a.chains) {
    cacheChains((_b = props.connectOptions) == null ? void 0 : _b.chains);
  }
  if ((_c = props.connectOptions) == null ? void 0 : _c.chain) {
    cacheChains([(_d = props.connectOptions) == null ? void 0 : _d.chain]);
  }
  let content = null;
  const metadata = props.payOptions && "metadata" in props.payOptions ? props.payOptions.metadata : null;
  if (!localeQuery.data) {
    content = (0, import_jsx_runtime8.jsx)("div", { style: {
      minHeight: "350px",
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    }, children: (0, import_jsx_runtime8.jsx)(Spinner, { size: "xl", color: "secondaryText" }) });
  } else {
    content = (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [screen === "buy" && (0, import_jsx_runtime8.jsx)(BuyScreen, { title: (metadata == null ? void 0 : metadata.name) || "Buy", isEmbed: true, supportedTokens: props.supportedTokens, theme, client: props.client, connectLocale: localeQuery.data, payOptions: props.payOptions || {
      mode: "fund_wallet"
    }, onDone: () => {
      var _a2;
      if (((_a2 = props.payOptions) == null ? void 0 : _a2.mode) === "transaction") {
        setScreen("execute-tx");
      }
    }, connectOptions: props.connectOptions, onBack: void 0 }), screen === "execute-tx" && ((_e = props.payOptions) == null ? void 0 : _e.mode) === "transaction" && props.payOptions.transaction && (0, import_jsx_runtime8.jsx)(ExecutingTxScreen, { tx: props.payOptions.transaction, closeModal: () => {
      setScreen("buy");
    }, onBack: () => {
      setScreen("buy");
    }, onTxSent: () => {
    } })] });
  }
  return (0, import_jsx_runtime8.jsx)(CustomThemeProvider, { theme, children: (0, import_jsx_runtime8.jsx)(EmbedContainer, { modalSize: "compact", style: props.style, className: props.className, children: (0, import_jsx_runtime8.jsx)(DynamicHeight, { children: content }) }) });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/useConnectModal.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
function useConnectModal() {
  const setRootEl = (0, import_react11.useContext)(SetRootElementContext);
  const [isConnecting, setIsConnecting] = (0, import_react11.useState)(false);
  const connect = (0, import_react11.useCallback)((props) => {
    function cleanup() {
      setIsConnecting(false);
      setRootEl(void 0);
    }
    return new Promise((resolve, reject) => {
      setIsConnecting(true);
      getConnectLocale(props.locale || "en_US").then((locale) => {
        setRootEl((0, import_jsx_runtime9.jsx)(Modal2, { ...props, onConnect: (w) => {
          resolve(w);
          cleanup();
        }, onClose: () => {
          reject();
          cleanup();
        }, connectLocale: locale }));
      }).catch(() => {
        reject();
        cleanup();
      });
    });
  }, [setRootEl]);
  return { connect, isConnecting };
}
function Modal2(props) {
  const wallets = (0, import_react11.useMemo)(() => props.wallets || getDefaultWallets({
    appMetadata: props.appMetadata,
    chains: props.chains
  }), [props.wallets, props.appMetadata, props.chains]);
  const size = (0, import_react11.useMemo)(() => {
    return !canFitWideModal() || wallets.length === 1 ? "compact" : props.size || "wide";
  }, [props.size, wallets.length]);
  const meta = (0, import_react11.useMemo)(() => {
    return {
      privacyPolicyUrl: props.privacyPolicyUrl,
      showThirdwebBranding: props.showThirdwebBranding,
      termsOfServiceUrl: props.termsOfServiceUrl,
      title: props.title,
      titleIconUrl: props.titleIcon
    };
  }, [
    props.privacyPolicyUrl,
    props.showThirdwebBranding,
    props.termsOfServiceUrl,
    props.title,
    props.titleIcon
  ]);
  return (0, import_jsx_runtime9.jsx)(WalletUIStatesProvider, { theme: props.theme, isOpen: true, children: (0, import_jsx_runtime9.jsx)(ConnectModal_default, {
    onClose: props.onClose,
    shouldSetActive: props.setActive === void 0 ? true : props.setActive,
    accountAbstraction: props.accountAbstraction,
    // TODO: not set up in `useConnectModal` for some reason?
    auth: void 0,
    chain: props.chain,
    client: props.client,
    connectLocale: props.connectLocale,
    meta,
    size,
    welcomeScreen: props.welcomeScreen,
    isEmbed: false,
    localeId: props.locale || "en_US",
    onConnect: props.onConnect,
    recommendedWallets: props.recommendedWallets,
    showAllWallets: props.showAllWallets,
    wallets,
    chains: props.chains,
    walletConnect: props.walletConnect
  }) });
}

// node_modules/thirdweb/dist/esm/react/web/ui/prebuilt/thirdweb/ClaimButton/index.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function ClaimButton(props) {
  const { children, contractAddress, client, chain, claimParams, payModal } = props;
  const defaultPayModalMetadata = payModal ? payModal.metadata : void 0;
  const contract = getContract({
    address: contractAddress,
    client,
    chain
  });
  const { data: payMetadata } = useReadContract(getPayMetadata, {
    contract,
    tokenId: claimParams.type === "ERC1155" ? claimParams.tokenId : void 0,
    queryOptions: {
      enabled: !defaultPayModalMetadata
    }
  });
  const account = useActiveAccount();
  const { mutateAsync } = useSendAndConfirmTransaction();
  return (0, import_jsx_runtime10.jsx)(TransactionButton, { payModal: {
    metadata: defaultPayModalMetadata || payMetadata,
    ...payModal
  }, transaction: async () => {
    if (!account) {
      throw new Error("No account detected");
    }
    const [claimTx, { getApprovalForTransaction: getApprovalForTransaction2 }] = await Promise.all([
      getClaimTransaction({
        contract,
        account,
        claimParams
      }),
      import("./getApprovalForTransaction-DJGKLEMY.js")
    ]);
    const approveTx = await getApprovalForTransaction2({
      transaction: claimTx,
      account
    });
    if (approveTx) {
      await mutateAsync(approveTx);
    }
    return claimTx;
  }, ...props, children });
}
async function getPayMetadata(options) {
  var _a, _b;
  const { contract, tokenId } = options;
  const [contractMetadata, nft] = await Promise.all([
    getContractMetadata(options),
    tokenId ? getNFT({ contract, tokenId }) : void 0
  ]);
  if (tokenId) {
    return {
      image: (_a = nft == null ? void 0 : nft.metadata) == null ? void 0 : _a.image,
      name: (_b = nft == null ? void 0 : nft.metadata) == null ? void 0 : _b.name
    };
  }
  return {
    image: contractMetadata == null ? void 0 : contractMetadata.image,
    name: contractMetadata == null ? void 0 : contractMetadata.name
  };
}
async function getClaimTransaction({ contract, account, claimParams }) {
  switch (claimParams.type) {
    case "ERC721":
      return await getERC721ClaimTo({ contract, account, claimParams });
    case "ERC1155":
      return await getERC1155ClaimTo({ contract, account, claimParams });
    case "ERC20": {
      return await getERC20ClaimTo({ contract, account, claimParams });
    }
    default:
      throw new Error("Invalid contract type. Must be either NFT Drop (ERC721), Edition Drop (ERC1155) or Token Drop (ERC20)");
  }
}
async function getERC721ClaimTo({ contract, account, claimParams }) {
  const [{ isERC721: isERC7212 }, { isClaimSupported }, { claimTo }] = await Promise.all([
    import("./isERC721-QY5OZD6L.js"),
    import("./claim-5UBIGR6N.js"),
    import("./claimTo-QXTEW5W5.js")
  ]);
  const [is721, claimSupported] = await Promise.all([
    isERC7212({ contract }).catch(() => false),
    isClaimSupported(contract).catch(() => false)
  ]);
  if (!is721) {
    throw new Error("Not an ERC721 contract");
  }
  if (!claimSupported) {
    throw new Error("Not a valid NFT Drop (ERC721) contract");
  }
  return claimTo({
    contract,
    to: (account == null ? void 0 : account.address) || "",
    quantity: claimParams.quantity
  });
}
async function getERC1155ClaimTo({ contract, account, claimParams }) {
  const [{ isERC1155: isERC11552 }, { isClaimSupported }, { claimTo }] = await Promise.all([
    import("./isERC1155-M2NVGV5G.js"),
    import("./claim-D7GYSLD4.js"),
    import("./claimTo-VLAYVLTW.js")
  ]);
  const [is1155, claimSupported] = await Promise.all([
    isERC11552({ contract }).catch(() => false),
    isClaimSupported(contract).catch(() => false)
  ]);
  if (!is1155) {
    throw new Error("Not a valid ERC1155 contract");
  }
  if (!claimSupported) {
    throw new Error("Not a valid thirdweb Edition Drop contract");
  }
  return claimTo({
    contract,
    to: (account == null ? void 0 : account.address) || "",
    quantity: claimParams.quantity,
    tokenId: claimParams.tokenId
  });
}
async function getERC20ClaimTo({ contract, account, claimParams }) {
  const [{ isClaimSupported }, { claimTo }] = await Promise.all([
    import("./claim-PDLIC34F.js"),
    import("./claimTo-3KZ7YJHD.js")
  ]);
  const claimSupported = await isClaimSupported(contract).catch(() => false);
  if (!claimSupported) {
    throw new Error("Not a valid thirdweb Token Drop contract");
  }
  if ("quantity" in claimParams) {
    return claimTo({
      contract,
      to: (account == null ? void 0 : account.address) || "",
      quantity: claimParams.quantity
    });
  }
  if ("quantityInWei" in claimParams) {
    return claimTo({
      contract,
      to: (account == null ? void 0 : account.address) || "",
      quantityInWei: claimParams.quantityInWei
    });
  }
  throw new Error("Missing quantity or quantityInWei");
}

// node_modules/thirdweb/dist/esm/react/web/ui/prebuilt/thirdweb/BuyDirectListingButton/index.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
function BuyDirectListingButton(props) {
  const { contractAddress, listingId, children, chain, client, quantity, payModal } = props;
  const defaultPayModalMetadata = payModal ? payModal.metadata : void 0;
  const account = useActiveAccount();
  const contract = getContract({
    address: contractAddress,
    client,
    chain
  });
  const { data: payMetadata } = useReadContract(getPayMetadata2, {
    contract,
    listingId,
    queryOptions: {
      enabled: !defaultPayModalMetadata
    }
  });
  const { mutateAsync } = useSendAndConfirmTransaction();
  const prepareBuyTransaction = (0, import_react12.useCallback)(async () => {
    if (!account) {
      throw new Error("No account detected");
    }
    const [listing, { getApprovalForTransaction: getApprovalForTransaction2 }, { buyFromListing }] = await Promise.all([
      getListing({
        contract,
        listingId
      }),
      import("./getApprovalForTransaction-DJGKLEMY.js"),
      import("./buyFromListing-M4CMZZRD.js")
    ]);
    if (!listing) {
      throw new Error(`Could not retrieve listing with ID: ${listingId}`);
    }
    let _quantity = 1n;
    if (listing.asset.type === "ERC721") {
      if (typeof quantity === "bigint" && (quantity !== 1n || quantity < 0n)) {
        throw new Error("Invalid quantity. This is an ERC721 listing & quantity is always `1n`");
      }
    } else if (listing.asset.type === "ERC1155") {
      if (typeof quantity === "bigint") {
        if (quantity > listing.quantity) {
          throw new Error(`quantity exceeds available amount. Available: ${listing.quantity.toString()}`);
        }
        if (quantity < 0n) {
          throw new Error("Invalid quantity. Should be at least 1n");
        }
        _quantity = quantity;
      }
      _quantity = listing.quantity;
    }
    const buyTx = buyFromListing({
      contract,
      listingId,
      quantity: _quantity,
      recipient: (account == null ? void 0 : account.address) || ""
    });
    const approveTx = await getApprovalForTransaction2({
      transaction: buyTx,
      account
    });
    if (approveTx) {
      await mutateAsync(approveTx);
    }
    return buyTx;
  }, [account, contract, quantity, listingId, mutateAsync]);
  return (0, import_jsx_runtime11.jsx)(TransactionButton, { payModal: {
    metadata: defaultPayModalMetadata || payMetadata,
    ...payModal
  }, transaction: () => prepareBuyTransaction(), ...props, children });
}
async function getPayMetadata2(options) {
  var _a, _b, _c, _d;
  const listing = await getListing(options);
  if (!listing) {
    return { name: void 0, image: void 0 };
  }
  return {
    name: (_b = (_a = listing.asset) == null ? void 0 : _a.metadata) == null ? void 0 : _b.name,
    image: (_d = (_c = listing.asset) == null ? void 0 : _c.metadata) == null ? void 0 : _d.image
  };
}

// node_modules/thirdweb/dist/esm/react/web/ui/prebuilt/thirdweb/CreateDirectListingButton/index.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/extensions/marketplace/__generated__/IDirectListings/write/createListing.js
var FN_SELECTOR = "0x746415b5";
var FN_INPUTS = [
  {
    type: "tuple",
    name: "_params",
    components: [
      {
        type: "address",
        name: "assetContract"
      },
      {
        type: "uint256",
        name: "tokenId"
      },
      {
        type: "uint256",
        name: "quantity"
      },
      {
        type: "address",
        name: "currency"
      },
      {
        type: "uint256",
        name: "pricePerToken"
      },
      {
        type: "uint128",
        name: "startTimestamp"
      },
      {
        type: "uint128",
        name: "endTimestamp"
      },
      {
        type: "bool",
        name: "reserved"
      }
    ]
  }
];
var FN_OUTPUTS = [
  {
    type: "uint256",
    name: "listingId"
  }
];
function createListing(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.params];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/marketplace/direct-listings/write/createListing.js
function createListing2(options) {
  return createListing({
    contract: options.contract,
    asyncParams: async () => {
      const assetContract = getContract({
        ...options.contract,
        address: options.assetContractAddress
      });
      const rpcClient = getRpcClient(options.contract);
      const [assetIsERC721, assetIsERC1155, lastestBlock] = await Promise.all([
        isERC721({ contract: assetContract }),
        isERC1155({ contract: assetContract }),
        eth_getBlockByNumber(rpcClient, { blockTag: "latest" })
      ]);
      if (!assetIsERC721 && !assetIsERC1155) {
        throw new Error("AssetContract must implement ERC 1155 or ERC 721.");
      }
      let startTimestamp = BigInt(Math.floor((options.startTimestamp ?? /* @__PURE__ */ new Date()).getTime() / 1e3));
      const endTimestamp = BigInt(Math.floor((options.endTimestamp ?? new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1e3)).getTime() / 1e3));
      if (startTimestamp <= lastestBlock.timestamp) {
        startTimestamp = lastestBlock.timestamp + 1n;
      }
      if (startTimestamp >= endTimestamp) {
        throw new Error("Start time must be before end time.");
      }
      let quantity;
      if (assetIsERC721) {
        quantity = 1n;
      } else {
        quantity = options.quantity ?? 1n;
      }
      const currencyAddress = options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS;
      let pricePerToken;
      if ("pricePerToken" in options) {
        if (isNativeTokenAddress(currencyAddress)) {
          pricePerToken = toUnits(options.pricePerToken, 18);
        } else {
          const currencyContract = getContract({
            ...options.contract,
            address: currencyAddress
          });
          const { decimals } = await import("./decimals-OMBHT4NA.js");
          const currencyDecimals = await decimals({
            contract: currencyContract
          });
          pricePerToken = toUnits(options.pricePerToken, currencyDecimals);
        }
      } else {
        pricePerToken = BigInt(options.pricePerTokenWei);
      }
      return {
        params: {
          assetContract: options.assetContractAddress,
          tokenId: options.tokenId,
          currency: options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS,
          quantity,
          pricePerToken,
          startTimestamp,
          endTimestamp,
          reserved: options.isReservedListing ?? false
        },
        overrides: {
          extraGas: 50000n
          // add extra gas to account for router call
        }
      };
    }
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/prebuilt/thirdweb/CreateDirectListingButton/index.js
function CreateDirectListingButton(props) {
  const { contractAddress, chain, client, children, payModal, assetContractAddress, tokenId } = props;
  const marketplaceContract = getContract({
    address: contractAddress,
    chain,
    client
  });
  const account = useActiveAccount();
  const defaultPayModalMetadata = payModal ? payModal.metadata : void 0;
  const { data: payMetadata } = useReadContract(getPayMetadata3, {
    contract: getContract({
      address: assetContractAddress,
      chain,
      client
    }),
    tokenId,
    queryOptions: {
      enabled: !defaultPayModalMetadata
    }
  });
  const { mutateAsync } = useSendAndConfirmTransaction();
  const prepareTransaction = (0, import_react13.useCallback)(async () => {
    if (!account) {
      throw new Error("No account detected");
    }
    const listingTx = createListing2({
      contract: marketplaceContract,
      ...props
    });
    const approveTx = await getApprovalForTransaction({
      transaction: listingTx,
      account
    });
    if (approveTx) {
      await mutateAsync(approveTx);
    }
    return listingTx;
  }, [marketplaceContract, props, account, mutateAsync]);
  return (0, import_jsx_runtime12.jsx)(TransactionButton, { transaction: () => prepareTransaction(), payModal: {
    metadata: defaultPayModalMetadata || payMetadata,
    ...payModal
  }, ...props, children });
}
async function getPayMetadata3(options) {
  var _a, _b, _c, _d;
  const [{ isERC721: isERC7212 }, { isERC1155: isERC11552 }, { getContractMetadata: getContractMetadata2 }, { getNFT: getERC721 }, { getNFT: getERC1155 }] = await Promise.all([
    import("./isERC721-QY5OZD6L.js"),
    import("./isERC1155-M2NVGV5G.js"),
    import("./getContractMetadata-EGPS5VDZ.js"),
    import("./getNFT-F4AVWZU3.js"),
    import("./getNFT-2PE3GPEU.js")
  ]);
  const [is721, is1155, contractMetadata] = await Promise.all([
    isERC7212(options),
    isERC11552(options),
    getContractMetadata2(options)
  ]);
  if (is721) {
    const nft = await getERC721(options);
    return {
      image: (_a = nft == null ? void 0 : nft.metadata) == null ? void 0 : _a.image,
      name: (_b = nft == null ? void 0 : nft.metadata) == null ? void 0 : _b.name
    };
  }
  if (is1155) {
    const nft = await getERC1155(options);
    return {
      image: (_c = nft == null ? void 0 : nft.metadata) == null ? void 0 : _c.image,
      name: (_d = nft == null ? void 0 : nft.metadata) == null ? void 0 : _d.name
    };
  }
  return {
    image: contractMetadata == null ? void 0 : contractMetadata.image,
    name: contractMetadata == null ? void 0 : contractMetadata.name
  };
}
export {
  AutoConnect,
  BuyDirectListingButton,
  ClaimButton,
  ConnectButton,
  ConnectEmbed,
  CreateDirectListingButton,
  MediaRenderer,
  PayEmbed,
  ThirdwebProvider,
  TransactionButton,
  createContractQuery,
  darkTheme,
  defaultTokens,
  getDefaultToken,
  lightTheme,
  useActiveAccount,
  useActiveWallet,
  useActiveWalletChain,
  useActiveWalletConnectionStatus,
  useAutoConnect,
  useBlockNumber,
  useBuyHistory,
  useBuyWithCryptoHistory,
  useBuyWithCryptoQuote,
  useBuyWithCryptoStatus,
  useBuyWithFiatHistory,
  useBuyWithFiatQuote,
  useBuyWithFiatStatus,
  useCallsStatus,
  useCapabilities,
  useChainMetadata,
  useConnect,
  useConnectModal,
  useConnectedWallets,
  useConnectionManager,
  useContractEvents,
  useDisconnect,
  useEnsAvatar,
  useEnsName,
  useEstimateGas,
  useEstimateGasCost,
  useInvalidateContractQuery,
  useIsAutoConnecting,
  useNetworkSwitcherModal,
  usePostOnRampQuote,
  useReadContract,
  useSendAndConfirmTransaction,
  useSendBatchTransaction,
  useSendCalls,
  useSendTransaction,
  useSetActiveWallet,
  useSetActiveWalletConnectionStatus,
  useSimulateTransaction,
  useSwitchActiveWalletChain,
  useWaitForReceipt,
  useWalletBalance,
  useWalletDetailsModal,
  useWalletImage,
  useWalletInfo
};
//# sourceMappingURL=thirdweb_react.js.map
