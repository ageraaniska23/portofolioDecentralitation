import "./chunk-SY6M73X4.js";
import "./chunk-FPO5TL63.js";
import {
  readContract
} from "./chunk-BF6IWIHR.js";
import "./chunk-4OMQ45VH.js";
import "./chunk-KFTJWVLQ.js";
import "./chunk-7IZG4EP5.js";
import "./chunk-3UYCMIWJ.js";
import "./chunk-UV67MG5D.js";
import "./chunk-JMJMW6FX.js";
import "./chunk-CY3CMUVN.js";
import "./chunk-BNK74YTA.js";
import "./chunk-GDDTQ4UI.js";
import "./chunk-IAQW7B5J.js";
import "./chunk-Z2F5LG57.js";
import "./chunk-L46BJXKD.js";
import "./chunk-EWAXOTDC.js";
import "./chunk-TEQAYQEZ.js";
import "./chunk-SYYDPSNZ.js";
import "./chunk-MHFR2GDE.js";
import "./chunk-SUMWJFR6.js";
import "./chunk-EZ4JTQAA.js";
import "./chunk-SHWHM7JY.js";
import "./chunk-256EKJAK.js";

// node_modules/thirdweb/dist/esm/extensions/erc1155/__generated__/DropSinglePhase1155/read/claimCondition.js
var FN_SELECTOR = "0xe9703d25";
var FN_INPUTS = [
  {
    name: "_tokenId",
    type: "uint256",
    internalType: "uint256"
  }
];
var FN_OUTPUTS = [
  {
    name: "startTimestamp",
    type: "uint256",
    internalType: "uint256"
  },
  {
    name: "maxClaimableSupply",
    type: "uint256",
    internalType: "uint256"
  },
  {
    name: "supplyClaimed",
    type: "uint256",
    internalType: "uint256"
  },
  {
    name: "quantityLimitPerWallet",
    type: "uint256",
    internalType: "uint256"
  },
  {
    name: "merkleRoot",
    type: "bytes32",
    internalType: "bytes32"
  },
  {
    name: "pricePerToken",
    type: "uint256",
    internalType: "uint256"
  },
  {
    name: "currency",
    type: "address",
    internalType: "address"
  },
  {
    name: "metadata",
    type: "string",
    internalType: "string"
  }
];
async function claimCondition(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: [options.tokenId]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc1155/__generated__/IDrop1155/read/getActiveClaimConditionId.js
var FN_SELECTOR2 = "0x5ab063e8";
var FN_INPUTS2 = [
  {
    type: "uint256",
    name: "_tokenId"
  }
];
var FN_OUTPUTS2 = [
  {
    type: "uint256"
  }
];
async function getActiveClaimConditionId(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2],
    params: [options.tokenId]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc1155/__generated__/IDrop1155/read/getClaimConditionById.js
var FN_SELECTOR3 = "0xd45b28d7";
var FN_INPUTS3 = [
  {
    type: "uint256",
    name: "_tokenId"
  },
  {
    type: "uint256",
    name: "_conditionId"
  }
];
var FN_OUTPUTS3 = [
  {
    type: "tuple",
    name: "condition",
    components: [
      {
        type: "uint256",
        name: "startTimestamp"
      },
      {
        type: "uint256",
        name: "maxClaimableSupply"
      },
      {
        type: "uint256",
        name: "supplyClaimed"
      },
      {
        type: "uint256",
        name: "quantityLimitPerWallet"
      },
      {
        type: "bytes32",
        name: "merkleRoot"
      },
      {
        type: "uint256",
        name: "pricePerToken"
      },
      {
        type: "address",
        name: "currency"
      },
      {
        type: "string",
        name: "metadata"
      }
    ]
  }
];
async function getClaimConditionById(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR3, FN_INPUTS3, FN_OUTPUTS3],
    params: [options.tokenId, options.conditionId]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc1155/drops/read/getActiveClaimCondition.js
async function getActiveClaimCondition(options) {
  const getActiveClaimConditionMultiPhase = async () => {
    const conditionId = await getActiveClaimConditionId(options);
    return getClaimConditionById({ ...options, conditionId });
  };
  const getActiveClaimConditionSinglePhase = async () => {
    const [startTimestamp, maxClaimableSupply, supplyClaimed, quantityLimitPerWallet, merkleRoot, pricePerToken, currency, metadata] = await claimCondition({ ...options, tokenId: options.tokenId });
    return {
      startTimestamp,
      maxClaimableSupply,
      supplyClaimed,
      quantityLimitPerWallet,
      merkleRoot,
      pricePerToken,
      currency,
      metadata
    };
  };
  const results = await Promise.allSettled([
    getActiveClaimConditionMultiPhase(),
    getActiveClaimConditionSinglePhase()
  ]);
  const condition = results.find((result) => result.status === "fulfilled");
  if ((condition == null ? void 0 : condition.status) === "fulfilled") {
    return condition.value;
  }
  throw new Error("Claim condition not found");
}
export {
  getActiveClaimCondition
};
//# sourceMappingURL=getActiveClaimCondition-JVMFBFQE.js.map
